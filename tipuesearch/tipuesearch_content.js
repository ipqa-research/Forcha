var tipuesearch = {"pages":[{"title":" Forcha ","text":"Forcha Characterization Characterization Developer Info Oscar Therán PhD student","tags":"home","loc":"index.html"},{"title":"FluidData – Forcha ","text":"type, public :: FluidData Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: def_comp_mw (:) set of corresponding molecular weights of defined components integer, public :: def_comp_nc number of defined components being considered in the oil real(kind=pr), public, allocatable :: def_comp_w (:) mass fractions of the defined compounds real(kind=pr), public, allocatable :: def_comp_z (:) set of corresponding mole fractions of defined components character(len=15), public, allocatable :: def_components (:) set of defined components being considered in the oil character(len=:), public, allocatable :: filename integer, public :: numbers_ps number of pseudos in which the scn fractions grouped. real(kind=pr), public :: plus_density experimental density of the plus fraction real(kind=pr), public :: plus_mw molecular weight of residual fraction real(kind=pr), public :: plus_w mass fractions of the plus fraction real(kind=pr), public :: plus_z composition of residual fraction real(kind=pr), public, allocatable :: product_z_mw_def_comp (:) product between composition and molecular weight of defind components real(kind=pr), public :: product_z_mw_plus product between composition and molecular weight of residual fraction real(kind=pr), public, allocatable :: product_z_mw_scn (:) product between composition and molecular weight of scn fractions integer, public, allocatable :: scn (:) set of singles cuts being considered in the oil real(kind=pr), public, allocatable :: scn_density (:) set of corresponding densities of scn cuts real(kind=pr), public, allocatable :: scn_mw (:) set of corresponding molecular weights of scn cuts integer, public :: scn_nc number of single cuts being considered in the oil integer, public :: scn_nc_ps CN from which all SCN fractions will be lumped into the specified number of pseudos character(len=15), public :: scn_plus name of residual fraction real(kind=pr), public, allocatable :: scn_w (:) !! mass fractions of the scn-s compounds real(kind=pr), public, allocatable :: scn_z (:) set of corresponding mole fractions of scn cuts real(kind=pr), public :: sum_z_mw_i sum of the product between composition and molecular weight of the fluid’s compounds real(kind=pr), public, allocatable :: w (:) mass fractions of the fluid’s compounds","tags":"","loc":"type/fluiddata.html"},{"title":"FluidDataOut – Forcha ","text":"type, public :: FluidDataOut Components Type Visibility Attributes Name Initial real(kind=pr), public :: C C constants which is used in equation real(kind=pr), public :: a output real variable. Slope of the best feasible regression line. real(kind=pr), public :: a_60 A constant for Cmax60 line. real(kind=pr), public :: a_blr A constant for best linear regression line. real(kind=pr), public :: a_d ad constant which is used in equation for density. real(kind=pr), public :: a_lim A constant for limit feasible line. real(kind=pr), public :: b output real variable. Intercept of the best feasible regression line. real(kind=pr), public :: b_60 B constant for Cmax60 line. real(kind=pr), public :: b_blr B constant for best linear regression line. real(kind=pr), public :: b_d bd constant which is used in equation for density. real(kind=pr), public :: b_lim B constant for limit feasible line. integer, public :: c_max output CN at which plus_z is reached, as the summation of single z(i) from the best linear distribution (blr) integer, public :: c_max_60 integer, public :: c_max_blr integer, public :: c_max_lim real(kind=pr), public, allocatable :: carbon_number_plus (:) integer, public :: i_last integer, public :: last_C real(kind=pr), public, allocatable :: log_scn_z (:) set of corresponding mole fractions of scn cuts calculated integer, public :: n_init integer, public :: nc_plus number of elements in the distribution of C20+ real(kind=pr), public, allocatable :: plus6_density (:) real(kind=pr), public :: plus_mw molecular weight of residual fraction real(kind=pr), public :: plus_w real(kind=pr), public :: plus_z composition of residual fraction real(kind=pr), public, allocatable :: plus_z_i (:) real(kind=pr), public :: plus_zm real(kind=pr), public, allocatable :: product_z_mw_plus_i (:) real(kind=pr), public :: r2 output real variable. Square correlation coefficient. real(kind=pr), public, allocatable :: scn_i (:) real(kind=pr), public, allocatable :: scn_mw (:) set of corresponding molecular weights of scn cuts real(kind=pr), public, allocatable :: scn_z (:) set of corresponding mole fractions of scn cuts calculated real(kind=pr), public, allocatable :: scn_zm (:) real(kind=pr), public :: volume_6plus_cal","tags":"","loc":"type/fluiddataout.html"},{"title":"characterize – Forcha","text":"public  function characterize(file, mw_source, method, fix_C) result(characterization) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name character(len=*), intent(in) :: mw_source character(len=*), intent(in), optional :: method plus_mw or global_mw logical, intent(in), optional :: fix_C Return Value type( FluidDataOut ) Calls proc~~characterize~~CallsGraph proc~characterize characterize proc~data_from_file data_from_file proc~characterize->proc~data_from_file proc~density_funtion density_funtion proc~characterize->proc~density_funtion proc~get_c_or_m_plus get_c_or_m_plus proc~characterize->proc~get_c_or_m_plus proc~lump lump proc~characterize->proc~lump proc~mass_fractions mass_fractions proc~data_from_file->proc~mass_fractions proc~read_components read_components proc~data_from_file->proc~read_components proc~read_composition read_composition proc~data_from_file->proc~read_composition proc~read_density read_density proc~data_from_file->proc~read_density proc~read_molecular_weight read_molecular_weight proc~data_from_file->proc~read_molecular_weight proc~read_setup read_setup proc~data_from_file->proc~read_setup proc~calculate_volume_6plus calculate_volume_6plus proc~density_funtion->proc~calculate_volume_6plus proc~difference_mw_plus difference_mw_plus proc~get_c_or_m_plus->proc~difference_mw_plus proc~best_linear_regression Best_Linear_Regression proc~difference_mw_plus->proc~best_linear_regression proc~limitline LimitLine proc~difference_mw_plus->proc~limitline proc~line_c60_max Line_C60_max proc~difference_mw_plus->proc~line_c60_max proc~select_method select_method proc~difference_mw_plus->proc~select_method proc~mass_fractions->proc~read_composition proc~mass_fractions->proc~read_molecular_weight proc~mass_fractions->proc~read_setup proc~read_components->proc~read_setup proc~read_composition->proc~read_setup proc~read_density->proc~read_setup proc~read_molecular_weight->proc~read_setup proc~linear_regression Linear_Regression proc~best_linear_regression->proc~linear_regression Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( FluidData ), public :: fluid","tags":"","loc":"proc/characterize.html"},{"title":"Best_Linear_Regression – Forcha","text":"public  subroutine Best_Linear_Regression(scn_nc, scn, scn_z, plus_z, a, b, r2, n_init, c_max_blr) This subroutine calculates the best regression line for an fluid. Arguments Type Intent Optional Attributes Name integer, intent(in) :: scn_nc integer input variable set to the total number of single cuts being considered in the fluid integer, intent(in) :: scn (:) set of singles cuts being considered in the fluid real(kind=pr), intent(in) :: scn_z (:) set of corresponding mole fractions of scn cuts real(kind=pr), intent(in) :: plus_z composition of residual fraction from input file real(kind=pr), intent(out) :: a output real variable. Slope of the best regression line. real(kind=pr), intent(out) :: b output real variable. Intercept of the best regression line. real(kind=pr), intent(out) :: r2 output real variable. Square correlation coefficient. integer, intent(out) :: n_init minimum carbon number obtained from the best linear regression integer, intent(out) :: c_max_blr output CN at which plus_z is reached, as the summation of single z(i) from the best linear distribution (blr) Calls proc~~best_linear_regression~~CallsGraph proc~best_linear_regression Best_Linear_Regression proc~linear_regression Linear_Regression proc~best_linear_regression->proc~linear_regression Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~best_linear_regression~~CalledByGraph proc~best_linear_regression Best_Linear_Regression proc~difference_mw_plus difference_mw_plus proc~difference_mw_plus->proc~best_linear_regression proc~get_c_or_m_plus get_c_or_m_plus proc~get_c_or_m_plus->proc~difference_mw_plus proc~characterize characterize proc~characterize->proc~get_c_or_m_plus Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a_best real(kind=pr), public :: a_old real(kind=pr), public :: b_best real(kind=pr), public :: b_old integer, public :: i integer, public :: j integer, public :: k integer, public :: k_old integer, public :: n_best real(kind=pr), public :: r2_best real(kind=pr), public :: r2_old integer, public :: x_aux real(kind=pr), public, dimension(scn_nc) :: x_blr real(kind=pr), public, dimension(scn_nc) :: y_blr real(kind=pr), public :: z_aux real(kind=pr), public :: z_sum","tags":"","loc":"proc/best_linear_regression.html"},{"title":"LimitLine – Forcha","text":"public  subroutine LimitLine(scn_nc, scn, plus_z, a_blr, b_blr, a_lim, b_lim, c_max_lim, half) This subroutine obtains the limit line constants for an fluid. Arguments Type Intent Optional Attributes Name integer, intent(in) :: scn_nc integer input variable set to the total number of single cuts being considered in the fluid. integer, intent(in) :: scn (:) set of singles cuts being considered in the fluid. real(kind=pr), intent(in) :: plus_z composition of residual fraction from input file. real(kind=pr), intent(in) :: a_blr input constant from the Best linear regression. real(kind=pr), intent(in) :: b_blr input constant from the Best linear regression. real(kind=pr), intent(out) :: a_lim output real variable. Slope of the limit line. real(kind=pr), intent(out) :: b_lim output real variable. Intercept of the limit line. integer, intent(out) :: c_max_lim maximum carbon number obtained for limit line.\noutput CN at which plus_z is reached, as the summation of single z(i) from the limit distribution (blr). real(kind=pr), intent(out) :: half Called by proc~~limitline~~CalledByGraph proc~limitline LimitLine proc~difference_mw_plus difference_mw_plus proc~difference_mw_plus->proc~limitline proc~get_c_or_m_plus get_c_or_m_plus proc~get_c_or_m_plus->proc~difference_mw_plus proc~characterize characterize proc~characterize->proc~get_c_or_m_plus Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: cross_cn integer, public :: x_aux real(kind=pr), public :: z_aux real(kind=pr), public :: z_cross real(kind=pr), public :: z_lim","tags":"","loc":"proc/limitline.html"},{"title":"Line_C60_max – Forcha","text":"public  subroutine Line_C60_max(scn_nc, scn, plus_z, a_blr, b_blr, half, a_60, b_60, c_max_60) This subroutine obtains the Cmax60 line constants for an fluid. Arguments Type Intent Optional Attributes Name integer, intent(in) :: scn_nc integer input variable set to the total number of single cuts being considered in the fluid integer, intent(in) :: scn (:) set of singles cuts being considered in the fluid real(kind=pr), intent(in) :: plus_z composition of residual fraction from input file real(kind=pr), intent(in) :: a_blr input constant from the Best linear regression real(kind=pr), intent(in) :: b_blr input constant from the Best linear regression real(kind=pr), intent(in) :: half real(kind=pr), intent(out) :: a_60 output real variable. Slope of the limit line real(kind=pr), intent(out) :: b_60 output real variable. Intercept of the C60max line. integer, intent(out) :: c_max_60 output CN at which Zp is reached, as the summation of single z(i) from the Cmax60 distribution. Called by proc~~line_c60_max~~CalledByGraph proc~line_c60_max Line_C60_max proc~difference_mw_plus difference_mw_plus proc~difference_mw_plus->proc~line_c60_max proc~get_c_or_m_plus get_c_or_m_plus proc~get_c_or_m_plus->proc~difference_mw_plus proc~characterize characterize proc~characterize->proc~get_c_or_m_plus Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: F real(kind=pr), public :: F_tol real(kind=pr), public :: Zp_60 real(kind=pr), public :: a_old real(kind=pr), public :: a_tol real(kind=pr), public :: cross_cn real(kind=pr), public :: dF_dA real(kind=pr), public :: var_range integer, public :: x_aux real(kind=pr), public :: z_aux real(kind=pr), public :: z_cross real(kind=pr), public :: z_sum","tags":"","loc":"proc/line_c60_max.html"},{"title":"Linear_Regression – Forcha","text":"public  subroutine Linear_Regression(x, y, a, b, r2) This subroutine computes the regression line for a data set of x, y variables. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x (:) x: input array of length n which contains the set of independent variable real(kind=pr), intent(in) :: y (:) y: input array of length n which contains the set of dependent variable real(kind=pr), intent(out) :: a a: output real variable. Slope of the regression line real(kind=pr), intent(out) :: b b: output real variable. Intercept of the regression line real(kind=pr), intent(out) :: r2 Called by proc~~linear_regression~~CalledByGraph proc~linear_regression Linear_Regression proc~best_linear_regression Best_Linear_Regression proc~best_linear_regression->proc~linear_regression proc~difference_mw_plus difference_mw_plus proc~difference_mw_plus->proc~best_linear_regression proc~get_c_or_m_plus get_c_or_m_plus proc~get_c_or_m_plus->proc~difference_mw_plus proc~characterize characterize proc~characterize->proc~get_c_or_m_plus Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aux1 real(kind=pr), public :: aux2 real(kind=pr), public :: aux3 real(kind=pr), public :: aux4 real(kind=pr), public :: aux5 integer, public :: i integer, public :: n total number of data set. real(kind=pr), public :: t1 real(kind=pr), public :: t2 real(kind=pr), public :: t3 real(kind=pr), public :: t4","tags":"","loc":"proc/linear_regression.html"},{"title":"calculate_volume_6plus – Forcha","text":"public  subroutine calculate_volume_6plus(fluid, mw_source, characterization) this subroutine … Arguments Type Intent Optional Attributes Name type( FluidData ), intent(in) :: fluid character(len=*), intent(in) :: mw_source type( FluidDataOut ), intent(inout) :: characterization Called by proc~~calculate_volume_6plus~~CalledByGraph proc~calculate_volume_6plus calculate_volume_6plus proc~density_funtion density_funtion proc~density_funtion->proc~calculate_volume_6plus proc~characterize characterize proc~characterize->proc~density_funtion Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: plus6_density (:) real(kind=pr), public, allocatable :: plus_density_cal (:) real(kind=pr), public, allocatable :: scn_density_cal (:) real(kind=pr), public :: volume_6plus_cal","tags":"","loc":"proc/calculate_volume_6plus.html"},{"title":"density_funtion – Forcha","text":"public  subroutine density_funtion(fluid, mw_source, characterization) this subroutine … Arguments Type Intent Optional Attributes Name type( FluidData ) :: fluid character(len=*), intent(in) :: mw_source type( FluidDataOut ) :: characterization Calls proc~~density_funtion~~CallsGraph proc~density_funtion density_funtion proc~calculate_volume_6plus calculate_volume_6plus proc~density_funtion->proc~calculate_volume_6plus Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~density_funtion~~CalledByGraph proc~density_funtion density_funtion proc~characterize characterize proc~characterize->proc~density_funtion Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a_d_old real(kind=pr), public :: aux real(kind=pr), public :: difference real(kind=pr), public :: difference_old real(kind=pr), public :: volume_6plus_exp","tags":"","loc":"proc/density_funtion.html"},{"title":"difference_mw_plus – Forcha","text":"public  subroutine difference_mw_plus(fluid, mw_source, method, start, difference, characterization) this subroutine … Arguments Type Intent Optional Attributes Name type( FluidData ), intent(inout) :: fluid character(len=*), intent(in) :: mw_source character(len=*), intent(in), optional :: method logical :: start real(kind=pr), intent(out) :: difference type( FluidDataOut ), intent(inout) :: characterization Calls proc~~difference_mw_plus~~CallsGraph proc~difference_mw_plus difference_mw_plus proc~best_linear_regression Best_Linear_Regression proc~difference_mw_plus->proc~best_linear_regression proc~limitline LimitLine proc~difference_mw_plus->proc~limitline proc~line_c60_max Line_C60_max proc~difference_mw_plus->proc~line_c60_max proc~select_method select_method proc~difference_mw_plus->proc~select_method proc~linear_regression Linear_Regression proc~best_linear_regression->proc~linear_regression Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~difference_mw_plus~~CalledByGraph proc~difference_mw_plus difference_mw_plus proc~get_c_or_m_plus get_c_or_m_plus proc~get_c_or_m_plus->proc~difference_mw_plus proc~characterize characterize proc~characterize->proc~get_c_or_m_plus Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a_best real(kind=pr), public :: a_old real(kind=pr), public :: b_best real(kind=pr), public :: b_old integer, public, dimension(300) :: carbon_number_plus real(kind=pr), public :: denom set to molecular weights calculated by real(kind=pr), public :: half integer, public :: i integer, public :: i_0 integer, public :: j integer, public :: k integer, public :: k_old integer, public :: n_best real(kind=pr), public :: plus_mw_cal calculated molecular weight of  residual fraction real(kind=pr), public, dimension(300) :: plus_z_i real(kind=pr), public, dimension(300) :: product_z_mw_plus_i real(kind=pr), public :: r2_best real(kind=pr), public :: r2_old real(kind=pr), public, dimension(300) :: scn_i real(kind=pr), public :: sum_def_comp_z_plus compositions sum from (define component +1) to (plus component) real(kind=pr), public :: sum_z integer, public :: x_aux real(kind=pr), public :: z_aux real(kind=pr), public :: z_sum","tags":"","loc":"proc/difference_mw_plus.html"},{"title":"get_c_or_m_plus – Forcha","text":"public  subroutine get_c_or_m_plus(fluid, mw_source, method, fix_C, characterization) This subroutine… Arguments Type Intent Optional Attributes Name type( FluidData ) :: fluid character(len=*), intent(in) :: mw_source character(len=*), intent(in), optional :: method logical, intent(in) :: fix_C If C is < 12 or > 14 then fix to the\nclosest value. type( FluidDataOut ) :: characterization Calls proc~~get_c_or_m_plus~~CallsGraph proc~get_c_or_m_plus get_c_or_m_plus proc~difference_mw_plus difference_mw_plus proc~get_c_or_m_plus->proc~difference_mw_plus proc~best_linear_regression Best_Linear_Regression proc~difference_mw_plus->proc~best_linear_regression proc~limitline LimitLine proc~difference_mw_plus->proc~limitline proc~line_c60_max Line_C60_max proc~difference_mw_plus->proc~line_c60_max proc~select_method select_method proc~difference_mw_plus->proc~select_method proc~linear_regression Linear_Regression proc~best_linear_regression->proc~linear_regression Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_c_or_m_plus~~CalledByGraph proc~get_c_or_m_plus get_c_or_m_plus proc~characterize characterize proc~characterize->proc~get_c_or_m_plus Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: C_old real(kind=pr), public :: aux real(kind=pr), public :: difference real(kind=pr), public :: difference_old real(kind=pr), public, allocatable :: log_scn_z (:) logarithm of corresponding mole fractions of scn cutsn real(kind=pr), public :: plus_mw_old logical, public :: start","tags":"","loc":"proc/get_c_or_m_plus.html"},{"title":"get_critical_constants – Forcha","text":"public  subroutine get_critical_constants(fluid, characterization) this subroutine .... Arguments Type Intent Optional Attributes Name type( FluidData ), intent(in) :: fluid type( FluidDataOut ), intent(inout) :: characterization","tags":"","loc":"proc/get_critical_constants.html"},{"title":"lump – Forcha","text":"public  subroutine lump(fluid, characterization) This sobroutine …\nuse new variable for plus_w because type fluidata can’t be modified.\nesto es lo que haria en el write, luego eliminar este comentario. Arguments Type Intent Optional Attributes Name type( FluidData ), intent(in) :: fluid type( FluidDataOut ), intent(inout) :: characterization Called by proc~~lump~~CalledByGraph proc~lump lump proc~characterize characterize proc~characterize->proc~lump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: density_ps (:) integer, public :: i integer, public :: i_last integer, public :: i_ps integer, public, dimension(15) :: j_ps integer, public :: last integer, public :: last_C integer, public :: numbers_ps real(kind=pr), public, allocatable :: plus_mw_ps (:) real(kind=pr), public :: plus_w_new real(kind=pr), public, allocatable :: plus_z_i (:) real(kind=pr), public, allocatable :: plus_z_ps (:) integer, public :: prev_i real(kind=pr), public :: rec_zm real(kind=pr), public :: remain_plus_zm integer, public :: scn_nc_input inicial number of single cuts being considered in the oil from data input integer, public :: scn_nc_new new number of single cuts being considered in the oil defined as from scn_nc_ps variable. real(kind=pr), public :: sum_volume_ps real(kind=pr), public :: sum_z real(kind=pr), public :: sum_zm real(kind=pr), public :: sum_zm_last_ps real(kind=pr), public, allocatable :: var_aux_1 (:) real(kind=pr), public, allocatable :: var_aux_2 (:) real(kind=pr), public, allocatable :: w_ps (:) real(kind=pr), public, allocatable :: z_m_plus_i (:)","tags":"","loc":"proc/lump.html"},{"title":"select_method – Forcha","text":"public  subroutine select_method(fluid, mw_source, method, characterization) This subroutine defines the calculation method to perform the characterization,&\nbased on the available experimental data. If the molecular weight data is experimental,\ndefine the mole fractions, molecular weights and densities directly from the input file. \nOn the other hand, if the molecular weights are assumed, they are recalculated according \nto the methodology described by Martin et al and the molar fractions of the fluid are recalculated. Arguments Type Intent Optional Attributes Name type( FluidData ), intent(inout) :: fluid Derived type to save inlet or experimental information of fluid to be characterized. character(len=*), intent(in) :: mw_source This variable indicates the source of the input data, that is, whether they are experimental or not. character(len=*), intent(in), optional :: method this option allows choose beetwen obtaining plus_mw or global_mw reported in the experimental information . type( FluidDataOut ), intent(inout) :: characterization Derive type variable to save results of characterization methodology. Called by proc~~select_method~~CalledByGraph proc~select_method select_method proc~difference_mw_plus difference_mw_plus proc~difference_mw_plus->proc~select_method proc~get_c_or_m_plus get_c_or_m_plus proc~get_c_or_m_plus->proc~difference_mw_plus proc~characterize characterize proc~characterize->proc~get_c_or_m_plus Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: def_comp_moles (:) real(kind=pr), public :: plus_moles real(kind=pr), public, allocatable :: scn_moles (:) real(kind=pr), public :: sum_def_comp_z_plus compositions sum from (define component +1) to (plus component) real(kind=pr), public :: total_moles","tags":"","loc":"proc/select_method.html"},{"title":"data_in – Forcha","text":"public  subroutine data_in(Nfluid, Oil, Ncut, Ndef, DefComp, zdef, rMdef, rCN, zcomp, rMW, Den, Plus, rMWplus, DenPlus, Nps, wat, watPlus, zM, zMp, Z6p, sumV, w, rn) Arguments Type Intent Optional Attributes Name integer :: Nfluid character(len=7) :: Oil integer :: Ncut integer :: Ndef character(len=4) :: DefComp (maxD) real(kind=pr), dimension(maxD) :: zdef real(kind=pr), dimension(maxD) :: rMdef integer, dimension(330) :: rCN real(kind=pr), dimension(imax) :: zcomp real(kind=pr), dimension(imax) :: rMW real(kind=pr), dimension(imax) :: Den character(len=7) :: Plus real(kind=pr) :: rMWplus real(kind=pr) :: DenPlus integer :: Nps real(kind=pr), dimension(imax) :: wat real(kind=pr) :: watPlus real(kind=pr), dimension(imax) :: zM real(kind=pr) :: zMp real(kind=pr) :: Z6p real(kind=pr) :: sumV real(kind=pr), dimension(imax) :: w real(kind=pr), dimension(imax) :: rn Variables Type Visibility Attributes Name Initial real(kind=pr), public, dimension(imax) :: MWt integer, public :: file_unit_1 integer, public :: file_unit_2 integer, public :: file_unit_3 integer, public :: i integer, public, parameter :: imax = 48 character(len=30), public :: infile integer, public :: j integer, public, parameter :: maxD = 15 character(len=30), public :: outfile real(kind=pr), public, dimension(imax) :: zMdef real(kind=pr), public :: zMtotal","tags":"","loc":"proc/data_in.html"},{"title":"Best_Linear_Regression – Forcha","text":"public  subroutine Best_Linear_Regression(scn_nc, scn, scn_z, plus_z, a, b, r2, ninit) This subroutine calculates the best regression line for an oil. Arguments Type Intent Optional Attributes Name integer, intent(in) :: scn_nc integer input variable set to the total number of single cuts being considered in the oil integer, intent(in), allocatable :: scn (:) set of singles cuts being considered in the oil real, intent(in), allocatable :: scn_z (:) set of corresponding mole fractions of scn cuts real(kind=pr), intent(in) :: plus_z real(kind=pr), intent(out) :: a output real variable. Slope of the best regression line. real(kind=pr), intent(out) :: b output real variable. Intercept of the best regression line. real(kind=pr), intent(out) :: r2 output real variable. Square correlation coefficient. integer, intent(out) :: ninit minimum carbon number obtained from the best linear regression Calls proc~~best_linear_regression~2~~CallsGraph proc~best_linear_regression~2 Best_Linear_Regression linearregression linearregression proc~best_linear_regression~2->linearregression Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: abest real(kind=pr), public :: aold real(kind=pr), public :: bbest real(kind=pr), public :: bold integer, public :: cbmax integer, public :: i integer, public :: j integer, public :: k integer, public :: kold integer, public :: nbest real(kind=pr), public :: r2best real(kind=pr), public :: r2old real(kind=pr), public, allocatable :: xBR (:) integer, public :: xaux real(kind=pr), public, allocatable :: yBR (:) real(kind=pr), public :: zaux real(kind=pr), public :: zsum","tags":"","loc":"proc/best_linear_regression~2.html"},{"title":"GetNewMpfromC – Forcha","text":"public  subroutine GetNewMpfromC(start, C, Ncut, rCN, zM, zMp, Z6p, a, b, rMp, maxC, z, zpi, zMpi, Ndef, zp, w, rn, rMWplus, zcomp, zdef, rMW, rMdef, Mglobal) this subroutines for a C value returns the correponding  new M20+ value Arguments Type Intent Optional Attributes Name logical :: start real(kind=pr) :: C integer :: Ncut integer, dimension(imax) :: rCN real(kind=pr), dimension(imax) :: zM real(kind=pr) :: zMp real(kind=pr) :: Z6p real(kind=pr) :: a real(kind=pr) :: b real(kind=pr) :: rMp integer :: maxC real(kind=pr), dimension(imax) :: z real(kind=pr), dimension(300) :: zpi real(kind=pr), dimension(300) :: zMpi integer :: Ndef real(kind=pr) :: zp real(kind=pr), dimension(imax) :: w real(kind=pr), dimension(imax) :: rn real(kind=pr) :: rMWplus real(kind=pr), dimension(imax) :: zcomp real(kind=pr), dimension(maxD) :: zdef real(kind=pr), dimension(imax) :: rMW real(kind=pr), dimension(maxD) :: rMdef real(kind=pr) :: Mglobal Calls proc~~getnewmpfromc~~CallsGraph proc~getnewmpfromc GetNewMpfromC proc~difmpfromc difMpfromC proc~getnewmpfromc->proc~difmpfromc proc~difnewmp difnewMp proc~getnewmpfromc->proc~difnewmp bestlinearregression bestlinearregression proc~difmpfromc->bestlinearregression proc~limitline~2 LimitLine proc~difmpfromc->proc~limitline~2 proc~linec60max LineC60max proc~difmpfromc->proc~linec60max proc~difnewmp->bestlinearregression proc~difnewmp->proc~limitline~2 proc~difnewmp->proc~linec60max Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aux real(kind=pr), public :: dif real(kind=pr), public :: dold integer, public, parameter :: imax = 48 integer, public, parameter :: maxD = 15 real(kind=pr), public, dimension(imax) :: rM real(kind=pr), public :: rMpold","tags":"","loc":"proc/getnewmpfromc.html"},{"title":"LimitLine – Forcha","text":"public  subroutine LimitLine(Ncut, rCN, Zp, aBE, bBE, half, alim, blim, Cmax) Arguments Type Intent Optional Attributes Name integer :: Ncut integer, dimension(imax) :: rCN real(kind=pr) :: Zp real(kind=pr) :: aBE real(kind=pr) :: bBE real(kind=pr) :: half real(kind=pr) :: alim real(kind=pr) :: blim integer :: Cmax Called by proc~~limitline~2~~CalledByGraph proc~limitline~2 LimitLine proc~difmpfromc difMpfromC proc~difmpfromc->proc~limitline~2 proc~difmpfromcfull difMpfromCfull proc~difmpfromcfull->proc~limitline~2 proc~difnewmp difnewMp proc~difnewmp->proc~limitline~2 proc~get_c get_C proc~get_c->proc~difmpfromc proc~get_c->proc~difmpfromcfull proc~getnewmpfromc GetNewMpfromC proc~getnewmpfromc->proc~difmpfromc proc~getnewmpfromc->proc~difnewmp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: crossCN integer, public, parameter :: imax = 48 integer, public :: xaux real(kind=pr), public :: zaux real(kind=pr), public :: zcross real(kind=pr), public :: zlim","tags":"","loc":"proc/limitline~2.html"},{"title":"LineC60max – Forcha","text":"public  subroutine LineC60max(Ncut, Zp, rCN, aBE, bBE, half, a60, b60, C60max) Arguments Type Intent Optional Attributes Name integer :: Ncut real(kind=pr) :: Zp integer, dimension(imax) :: rCN real(kind=pr) :: aBE real(kind=pr) :: bBE real(kind=pr) :: half real(kind=pr) :: a60 real(kind=pr) :: b60 integer :: C60max Called by proc~~linec60max~~CalledByGraph proc~linec60max LineC60max proc~difmpfromc difMpfromC proc~difmpfromc->proc~linec60max proc~difmpfromcfull difMpfromCfull proc~difmpfromcfull->proc~linec60max proc~difnewmp difnewMp proc~difnewmp->proc~linec60max proc~get_c get_C proc~get_c->proc~difmpfromc proc~get_c->proc~difmpfromcfull proc~getnewmpfromc GetNewMpfromC proc~getnewmpfromc->proc~difmpfromc proc~getnewmpfromc->proc~difnewmp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: F real(kind=pr), public :: Ftol real(kind=pr), public :: Zp60 real(kind=pr), public :: a_old real(kind=pr), public :: atol real(kind=pr), public :: crossCN real(kind=pr), public :: dFdA integer, public, parameter :: imax = 48 real(kind=pr), public :: range integer, public :: xaux real(kind=pr), public :: zaux real(kind=pr), public :: zcross real(kind=pr), public :: zsum","tags":"","loc":"proc/linec60max.html"},{"title":"Linear_Regression – Forcha","text":"public  subroutine Linear_Regression(x, y, a, b, r2) This subroutine computes the regression line for a data set of x, y variables. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in), allocatable :: x (:) x: input array of length n which contains the set of independent variable real(kind=pr), intent(in), allocatable :: y (:) y: input array of length n which contains the set of dependent variable real(kind=pr), intent(out) :: a a: output real variable. Slope of the regression line real(kind=pr), intent(out) :: b b: output real variable. Intercept of the regression line real(kind=pr), intent(out) :: r2 Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aux1 real(kind=pr), public :: aux2 real(kind=pr), public :: aux3 real(kind=pr), public :: aux4 real(kind=pr), public :: aux5 integer, public :: i integer, public :: n total number of data set. real(kind=pr), public :: t1 real(kind=pr), public :: t2 real(kind=pr), public :: t3 real(kind=pr), public :: t4","tags":"","loc":"proc/linear_regression~2.html"},{"title":"difMpfromC – Forcha","text":"public  subroutine difMpfromC(start, C, Ncut, rCN, zM, zMp, Z6p, dif, a, b, rMp, maxC, z, zpi, zMpi, zcomp, zdef, zp) Uses data proc~~difmpfromc~~UsesGraph proc~difmpfromc difMpfromC module~data data proc~difmpfromc->module~data module~constants constants module~data->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name logical :: start real(kind=pr) :: C integer :: Ncut integer, dimension(imax) :: rCN real(kind=pr), dimension(imax) :: zM real(kind=pr) :: zMp real(kind=pr) :: Z6p real(kind=pr) :: dif real(kind=pr) :: a real(kind=pr) :: b real(kind=pr) :: rMp integer :: maxC real(kind=pr), dimension(imax) :: z real(kind=pr), dimension(300) :: zpi real(kind=pr), dimension(300) :: zMpi real(kind=pr), dimension(imax) :: zcomp real(kind=pr), dimension(maxD) :: zdef real(kind=pr) :: zp Calls proc~~difmpfromc~~CallsGraph proc~difmpfromc difMpfromC bestlinearregression bestlinearregression proc~difmpfromc->bestlinearregression proc~limitline~2 LimitLine proc~difmpfromc->proc~limitline~2 proc~linec60max LineC60max proc~difmpfromc->proc~linec60max Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~difmpfromc~~CalledByGraph proc~difmpfromc difMpfromC proc~get_c get_C proc~get_c->proc~difmpfromc proc~getnewmpfromc GetNewMpfromC proc~getnewmpfromc->proc~difmpfromc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: C60max integer, public :: CmaxL real(kind=pr), public :: a60 real(kind=pr), public :: aBE real(kind=pr), public :: alim real(kind=pr), public :: b60 real(kind=pr), public :: bBE real(kind=pr), public :: blim real(kind=pr), public :: half integer, public :: i integer, public :: i0 integer, public, parameter :: imax = 48 integer, public, parameter :: maxD = 15 real(kind=pr), public :: r2 real(kind=pr), public, dimension(imax) :: rM real(kind=pr), public :: rMpcalc real(kind=pr), public :: sumz integer, public, dimension(imax) :: x real(kind=pr), public, dimension(imax) :: ylog","tags":"","loc":"proc/difmpfromc.html"},{"title":"difMpfromCfull – Forcha","text":"public  subroutine difMpfromCfull(start, C, Ndef, Ncut, rCN, dif, a, b, rM, rMp, maxC, z, zp, zpi, zMpi, w, rn, zcomp, zdef) Uses data proc~~difmpfromcfull~~UsesGraph proc~difmpfromcfull difMpfromCfull module~data data proc~difmpfromcfull->module~data module~constants constants module~data->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name logical :: start real(kind=pr) :: C integer :: Ndef integer :: Ncut integer, dimension(imax) :: rCN real(kind=pr) :: dif real(kind=pr) :: a real(kind=pr) :: b real(kind=pr), dimension(imax) :: rM real(kind=pr) :: rMp integer :: maxC real(kind=pr), dimension(imax) :: z real(kind=pr) :: zp real(kind=pr), dimension(300) :: zpi real(kind=pr), dimension(300) :: zMpi real(kind=pr), dimension(imax) :: w real(kind=pr), dimension(imax) :: rn real(kind=pr), dimension(imax) :: zcomp real(kind=pr), dimension(maxD) :: zdef Calls proc~~difmpfromcfull~~CallsGraph proc~difmpfromcfull difMpfromCfull bestlinearregression bestlinearregression proc~difmpfromcfull->bestlinearregression proc~limitline~2 LimitLine proc~difmpfromcfull->proc~limitline~2 proc~linec60max LineC60max proc~difmpfromcfull->proc~linec60max Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~difmpfromcfull~~CalledByGraph proc~difmpfromcfull difMpfromCfull proc~get_c get_C proc~get_c->proc~difmpfromcfull Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: C60max integer, public :: CmaxL real(kind=pr), public :: a60 real(kind=pr), public :: aBE real(kind=pr), public :: alim real(kind=pr), public :: aold real(kind=pr), public :: b60 real(kind=pr), public :: bBE real(kind=pr), public :: blim real(kind=pr), public :: half integer, public :: i integer, public :: i0 integer, public, parameter :: imax = 48 integer, public, parameter :: maxD = 15 real(kind=pr), public :: r2 real(kind=pr), public :: rMpcalc real(kind=pr), public :: rntot real(kind=pr), public :: sumz integer, public, dimension(imax) :: x real(kind=pr), public, dimension(imax) :: ylog real(kind=pr), public, dimension(imax) :: ztotal","tags":"","loc":"proc/difmpfromcfull.html"},{"title":"difnewMp – Forcha","text":"public  subroutine difnewMp(start, C, Ndef, Ncut, rCN, dif, a, b, rM, rMp, maxC, z, zp, zpi, zMpi, w, rn, zcomp, zdef, rMW, rMdef, Mglobal) Uses data proc~~difnewmp~~UsesGraph proc~difnewmp difnewMp module~data data proc~difnewmp->module~data module~constants constants module~data->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. this subroutines for a C value returns the correponding Mp value Arguments Type Intent Optional Attributes Name logical :: start real(kind=pr) :: C integer :: Ndef integer :: Ncut integer, dimension(imax) :: rCN real(kind=pr) :: dif real(kind=pr) :: a real(kind=pr) :: b real(kind=pr), dimension(imax) :: rM real(kind=pr) :: rMp integer :: maxC real(kind=pr), dimension(imax) :: z real(kind=pr) :: zp real(kind=pr), dimension(300) :: zpi real(kind=pr), dimension(300) :: zMpi real(kind=pr), dimension(imax) :: w real(kind=pr), dimension(imax) :: rn real(kind=pr), dimension(imax) :: zcomp real(kind=pr), dimension(maxD) :: zdef real(kind=pr), dimension(imax) :: rMW real(kind=pr), dimension(maxD) :: rMdef real(kind=pr) :: Mglobal Calls proc~~difnewmp~~CallsGraph proc~difnewmp difnewMp bestlinearregression bestlinearregression proc~difnewmp->bestlinearregression proc~limitline~2 LimitLine proc~difnewmp->proc~limitline~2 proc~linec60max LineC60max proc~difnewmp->proc~linec60max Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~difnewmp~~CalledByGraph proc~difnewmp difnewMp proc~getnewmpfromc GetNewMpfromC proc~getnewmpfromc->proc~difnewmp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: C60max integer, public :: CmaxL real(kind=pr), public, dimension(imax) :: MWt real(kind=pr), public, dimension(300) :: ZM_1 real(kind=pr), public :: a60 real(kind=pr), public :: aBE real(kind=pr), public :: alim real(kind=pr), public :: aold real(kind=pr), public :: b60 real(kind=pr), public :: bBE real(kind=pr), public :: blim real(kind=pr), public :: half integer, public :: i integer, public :: i0 integer, public, parameter :: imax = 48 integer, public, parameter :: maxD = 15 real(kind=pr), public :: r2 real(kind=pr), public :: rMpcalc real(kind=pr), public :: rntot real(kind=pr), public :: sumz integer, public, dimension(imax) :: x real(kind=pr), public, dimension(imax) :: ylog real(kind=pr), public, dimension(imax) :: ztotal","tags":"","loc":"proc/difnewmp.html"},{"title":"get_C – Forcha","text":"public  subroutine get_C(start, C, Ncut, rCN, zM, zMp, Z6p, a, b, rMp, maxC, z, zpi, zMpi, Ndef, zp, w, rn, rMWplus, zcomp, zdef) Arguments Type Intent Optional Attributes Name logical :: start real(kind=pr) :: C integer :: Ncut integer, dimension(imax) :: rCN real(kind=pr), dimension(imax) :: zM real(kind=pr) :: zMp real(kind=pr) :: Z6p real(kind=pr) :: a real(kind=pr) :: b real(kind=pr) :: rMp integer :: maxC real(kind=pr), dimension(imax) :: z real(kind=pr), dimension(300) :: zpi real(kind=pr), dimension(300) :: zMpi integer :: Ndef real(kind=pr) :: zp real(kind=pr), dimension(imax) :: w real(kind=pr), dimension(imax) :: rn real(kind=pr) :: rMWplus real(kind=pr), dimension(imax) :: zcomp real(kind=pr), dimension(maxD) :: zdef Calls proc~~get_c~~CallsGraph proc~get_c get_C proc~difmpfromc difMpfromC proc~get_c->proc~difmpfromc proc~difmpfromcfull difMpfromCfull proc~get_c->proc~difmpfromcfull bestlinearregression bestlinearregression proc~difmpfromc->bestlinearregression proc~limitline~2 LimitLine proc~difmpfromc->proc~limitline~2 proc~linec60max LineC60max proc~difmpfromc->proc~linec60max proc~difmpfromcfull->bestlinearregression proc~difmpfromcfull->proc~limitline~2 proc~difmpfromcfull->proc~linec60max Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Cold real(kind=pr), public :: aux real(kind=pr), public :: dif real(kind=pr), public :: dold integer, public, parameter :: imax = 48 integer, public, parameter :: maxD = 15 real(kind=pr), public, dimension(imax) :: rM","tags":"","loc":"proc/get_c.html"},{"title":"data_from_file – Forcha","text":"public  function data_from_file(file) result(data) This funtion allows to obtain experimental data from data imput Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name Return Value type( FluidData ) Calls proc~~data_from_file~~CallsGraph proc~data_from_file data_from_file proc~mass_fractions mass_fractions proc~data_from_file->proc~mass_fractions proc~read_components read_components proc~data_from_file->proc~read_components proc~read_composition read_composition proc~data_from_file->proc~read_composition proc~read_density read_density proc~data_from_file->proc~read_density proc~read_molecular_weight read_molecular_weight proc~data_from_file->proc~read_molecular_weight proc~read_setup read_setup proc~data_from_file->proc~read_setup proc~mass_fractions->proc~read_composition proc~mass_fractions->proc~read_molecular_weight proc~mass_fractions->proc~read_setup proc~read_components->proc~read_setup proc~read_composition->proc~read_setup proc~read_density->proc~read_setup proc~read_molecular_weight->proc~read_setup Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~data_from_file~~CalledByGraph proc~data_from_file data_from_file proc~characterize characterize proc~characterize->proc~data_from_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/data_from_file.html"},{"title":"mass_fractions – Forcha","text":"public  subroutine mass_fractions(file, w, product_z_mw_def_comp, product_z_mw_scn, sum_z_mw_i, product_z_mw_plus, def_comp_w, scn_w, plus_w) This routine obtains the mass fractions of the fluid’s compounds from\nthe input file, additionally, it calculates the product Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name real(kind=pr), intent(out), allocatable :: w (:) mass fractions of the fluid’s compounds real(kind=pr), intent(out), allocatable :: product_z_mw_def_comp (:) product between composition and molecular weight of defind components real(kind=pr), intent(out), allocatable :: product_z_mw_scn (:) product between composition and molecular weight of scn fractions real(kind=pr), intent(out) :: sum_z_mw_i sum of the product between composition and molecular weight of the fluid’s compounds real(kind=pr), intent(out) :: product_z_mw_plus product between composition and molecular weight of residual fraction real(kind=pr), intent(out), allocatable :: def_comp_w (:) real(kind=pr), intent(out), allocatable :: scn_w (:) real(kind=pr), intent(out) :: plus_w Calls proc~~mass_fractions~~CallsGraph proc~mass_fractions mass_fractions proc~read_composition read_composition proc~mass_fractions->proc~read_composition proc~read_molecular_weight read_molecular_weight proc~mass_fractions->proc~read_molecular_weight proc~read_setup read_setup proc~mass_fractions->proc~read_setup proc~read_composition->proc~read_setup proc~read_molecular_weight->proc~read_setup Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mass_fractions~~CalledByGraph proc~mass_fractions mass_fractions proc~data_from_file data_from_file proc~data_from_file->proc~mass_fractions proc~characterize characterize proc~characterize->proc~data_from_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: def_comp_mw (:) set of corresponding molecular weights of defined components integer, public :: def_comp_nc number of defined components being considered in the oil real(kind=pr), public, allocatable :: def_comp_z (:) set of corresponding mole fractions of defined components integer, public :: funit integer, public :: numbers_ps number of pseudos in which the scn fractions grouped real(kind=pr), public :: plus_mw molecular weight of residual fraction real(kind=pr), public :: plus_z composition of residual fraction real(kind=pr), public, allocatable :: product_z_mw_i (:) real(kind=pr), public, allocatable :: scn_mw (:) set of corresponding molecular weights of scn cuts integer, public :: scn_nc number of single cuts being considered in the oil integer, public :: scn_nc_ps CN from which all SCN fractions will be lumped into the specified number of pseudos real(kind=pr), public, allocatable :: scn_z (:) set of corresponding mole fractions of scn cuts","tags":"","loc":"proc/mass_fractions.html"},{"title":"read_components – Forcha","text":"public  subroutine read_components(file, def_components, scn, scn_plus) Reads the component names data from input file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name character(len=15), intent(out), allocatable :: def_components (:) names of defined components integer, intent(out), allocatable :: scn (:) names of scn fractions character(len=15), intent(out) :: scn_plus name of residual fraction Calls proc~~read_components~~CallsGraph proc~read_components read_components proc~read_setup read_setup proc~read_components->proc~read_setup Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_components~~CalledByGraph proc~read_components read_components proc~data_from_file data_from_file proc~data_from_file->proc~read_components proc~characterize characterize proc~characterize->proc~data_from_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: def_comp_nc number of defined components being considered in the oil integer, public :: funit integer, public :: numbers_ps number of pseudos in which the scn fractions grouped integer, public :: scn_nc number of single cuts being considered in the oil integer, public :: scn_nc_ps CN from which all SCN fractions will be lumped into the specified number of pseudos Namelists Namelist nml_components Variables Name Type Default Description def_components character(len=15) None names of defined components scn integer None names of scn fractions scn_plus character(len=15) None name of residual fraction","tags":"","loc":"proc/read_components.html"},{"title":"read_composition – Forcha","text":"public  subroutine read_composition(file, def_comp_z, scn_z, plus_z) Reads the molar compositions of each component from input file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name real(kind=pr), intent(out), allocatable :: def_comp_z (:) set of corresponding mole fractions of defined components real(kind=pr), intent(out), allocatable :: scn_z (:) set of corresponding mole fractions of scn cuts real(kind=pr), intent(out) :: plus_z composition of residual fraction from input file Calls proc~~read_composition~~CallsGraph proc~read_composition read_composition proc~read_setup read_setup proc~read_composition->proc~read_setup Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_composition~~CalledByGraph proc~read_composition read_composition proc~data_from_file data_from_file proc~data_from_file->proc~read_composition proc~mass_fractions mass_fractions proc~data_from_file->proc~mass_fractions proc~mass_fractions->proc~read_composition proc~characterize characterize proc~characterize->proc~data_from_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: def_comp_nc number of defined components being considered in the oil integer, public :: funit integer, public :: numbers_ps number of pseudos in which the scn fractions grouped integer, public :: scn_nc number of single cuts being considered in the oil integer, public :: scn_nc_ps CN from which all SCN fractions will be lumped into the specified number of pseudos Namelists Namelist nml_composition Variables Name Type Default Description def_comp_z real(kind=pr) None set of corresponding mole fractions of defined components scn_z real(kind=pr) None set of corresponding mole fractions of scn cuts plus_z real(kind=pr) None composition of residual fraction from input file","tags":"","loc":"proc/read_composition.html"},{"title":"read_density – Forcha","text":"public  subroutine read_density(file, scn_density, plus_density) Reads the density of each component from the input file and calculated molar volume since C6 fraction. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name real(kind=pr), intent(out), allocatable :: scn_density (:) set of corresponding densities of scn cuts real(kind=pr), intent(out) :: plus_density density of residual fraction from input file Calls proc~~read_density~~CallsGraph proc~read_density read_density proc~read_setup read_setup proc~read_density->proc~read_setup Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_density~~CalledByGraph proc~read_density read_density proc~data_from_file data_from_file proc~data_from_file->proc~read_density proc~characterize characterize proc~characterize->proc~data_from_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: def_comp_nc number of defined components being considered in the oil integer, public :: funit integer, public :: numbers_ps number of pseudos in which the scn fractions grouped integer, public :: scn_nc number of single cuts being considered in the oil integer, public :: scn_nc_ps CN from which all SCN fractions will be lumped into the specified number of pseudos Namelists Namelist nml_density Variables Name Type Default Description scn_density real(kind=pr) None set of corresponding densities of scn cuts plus_density real(kind=pr) None density of residual fraction from input file","tags":"","loc":"proc/read_density.html"},{"title":"read_molecular_weight – Forcha","text":"public  subroutine read_molecular_weight(file, def_comp_mw, scn_mw, plus_mw) Reads the molecular weights of each component from the input file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name real(kind=pr), intent(out), allocatable :: def_comp_mw (:) set of corresponding molecular weights of defined components real(kind=pr), intent(out), allocatable :: scn_mw (:) set of corresponding molecular weights of scn cuts real(kind=pr), intent(out) :: plus_mw molecular weight of residual fraction Calls proc~~read_molecular_weight~~CallsGraph proc~read_molecular_weight read_molecular_weight proc~read_setup read_setup proc~read_molecular_weight->proc~read_setup Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_molecular_weight~~CalledByGraph proc~read_molecular_weight read_molecular_weight proc~data_from_file data_from_file proc~data_from_file->proc~read_molecular_weight proc~mass_fractions mass_fractions proc~data_from_file->proc~mass_fractions proc~mass_fractions->proc~read_molecular_weight proc~characterize characterize proc~characterize->proc~data_from_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: def_comp_nc number of defined components being considered in the oil integer, public :: funit integer, public :: numbers_ps number of pseudos in which the scn fractions grouped integer, public :: scn_nc number of single cuts being considered in the oil integer, public :: scn_nc_ps CN from which all SCN fractions will be lumped into the specified number of pseudos Namelists Namelist nml_molecular_weight Variables Name Type Default Description def_comp_mw real(kind=pr) None set of corresponding molecular weights of defined components scn_mw real(kind=pr) None set of corresponding molecular weights of scn cuts plus_mw real(kind=pr) None molecular weight of residual fraction","tags":"","loc":"proc/read_molecular_weight.html"},{"title":"read_setup – Forcha","text":"public  subroutine read_setup(file, def_comp_nc, scn_nc, scn_nc_ps, numbers_ps) Reads the setup data from input file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name integer, intent(out) :: def_comp_nc number of defined components being considered in the oil integer, intent(out) :: scn_nc number of single cuts being considered in the oil integer, intent(out) :: scn_nc_ps CN from which all SCN fractions will be lumped into the specified number of pseudos integer, intent(out) :: numbers_ps number of pseudos in which the scn fractions grouped Called by proc~~read_setup~~CalledByGraph proc~read_setup read_setup proc~data_from_file data_from_file proc~data_from_file->proc~read_setup proc~mass_fractions mass_fractions proc~data_from_file->proc~mass_fractions proc~read_components read_components proc~data_from_file->proc~read_components proc~read_composition read_composition proc~data_from_file->proc~read_composition proc~read_density read_density proc~data_from_file->proc~read_density proc~read_molecular_weight read_molecular_weight proc~data_from_file->proc~read_molecular_weight proc~mass_fractions->proc~read_setup proc~mass_fractions->proc~read_composition proc~mass_fractions->proc~read_molecular_weight proc~read_components->proc~read_setup proc~read_composition->proc~read_setup proc~read_density->proc~read_setup proc~read_molecular_weight->proc~read_setup proc~characterize characterize proc~characterize->proc~data_from_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: funit Namelists Namelist nml_setup Variables Name Type Default Description def_comp_nc integer None number of defined components being considered in the oil scn_nc integer None number of single cuts being considered in the oil scn_nc_ps integer None CN from which all SCN fractions will be lumped into the specified number of pseudos numbers_ps integer None number of pseudos in which the scn fractions grouped","tags":"","loc":"proc/read_setup.html"},{"title":"Best_Linear_Regression – Forcha","text":"public  subroutine Best_Linear_Regression(scn_nc, scn, scn_z, plus_z, a, b, r2, n_init, c_max_blr) This subroutine calculates the best regression line for an oil. Arguments Type Intent Optional Attributes Name integer, intent(in) :: scn_nc integer input variable set to the total number of single cuts being considered in the oil integer, intent(in), allocatable :: scn (:) set of singles cuts being considered in the oil real(kind=pr), intent(in), allocatable :: scn_z (:) set of corresponding mole fractions of scn cuts real(kind=pr), intent(in) :: plus_z composition of residual fraction from input file real(kind=pr), intent(out) :: a output real variable. Slope of the best regression line. real(kind=pr), intent(out) :: b output real variable. Intercept of the best regression line. real(kind=pr), intent(out) :: r2 output real variable. Square correlation coefficient. integer, intent(out) :: n_init minimum carbon number obtained from the best linear regression integer, intent(out) :: c_max_blr output CN at which plus_z is reached, as the summation of single z(i) from the best linear distribution (blr) Calls proc~~best_linear_regression~3~~CallsGraph proc~best_linear_regression~3 Best_Linear_Regression proc~linear_regression~3 Linear_Regression proc~best_linear_regression~3->proc~linear_regression~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~best_linear_regression~3~~CalledByGraph proc~best_linear_regression~3 Best_Linear_Regression proc~difference_mw_plus~2 difference_mw_plus proc~difference_mw_plus~2->proc~best_linear_regression~3 proc~get_c_or_m_plus get_C_or_m_plus proc~get_c_or_m_plus->proc~difference_mw_plus~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a_best real(kind=pr), public :: a_old real(kind=pr), public :: b_best real(kind=pr), public :: b_old integer, public :: i integer, public :: j integer, public :: k integer, public :: k_old integer, public :: n_best real(kind=pr), public :: r2_best real(kind=pr), public :: r2_old integer, public :: x_aux real(kind=pr), public, dimension(scn_nc) :: x_blr real(kind=pr), public, dimension(scn_nc) :: y_blr real(kind=pr), public :: z_aux real(kind=pr), public :: z_sum","tags":"","loc":"proc/best_linear_regression~3.html"},{"title":"LimitLine – Forcha","text":"public  subroutine LimitLine(scn_nc, scn, plus_z, a_blr, b_blr, a_lim, b_lim, c_max_lim, half) This subroutine obtains the limit line constants for an oil. Arguments Type Intent Optional Attributes Name integer, intent(in) :: scn_nc integer input variable set to the total number of single cuts being considered in the oil integer, intent(in), allocatable :: scn (:) set of singles cuts being considered in the oil real(kind=pr), intent(in) :: plus_z composition of residual fraction from input file real(kind=pr), intent(in) :: a_blr input constant from the Best linear regression real(kind=pr), intent(in) :: b_blr input constant from the Best linear regression real(kind=pr), intent(out) :: a_lim output real variable. Slope of the limit line real(kind=pr), intent(out) :: b_lim output real variable. Intercept of the limit line. integer, intent(out) :: c_max_lim output CN at which plus_z is reached, as the summation of single z(i) from the limit distribution (blr) real(kind=pr), intent(out) :: half Called by proc~~limitline~3~~CalledByGraph proc~limitline~3 LimitLine proc~difference_mw_plus~2 difference_mw_plus proc~difference_mw_plus~2->proc~limitline~3 proc~get_c_or_m_plus get_C_or_m_plus proc~get_c_or_m_plus->proc~difference_mw_plus~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: cross_cn integer, public :: x_aux real(kind=pr), public :: z_aux real(kind=pr), public :: z_cross real(kind=pr), public :: z_lim","tags":"","loc":"proc/limitline~3.html"},{"title":"Line_C60_max – Forcha","text":"public  subroutine Line_C60_max(scn_nc, scn, plus_z, a_blr, b_blr, half, a_60, b_60, c_max_60) This subroutine obtains the Cmax60 line constants for an oil Arguments Type Intent Optional Attributes Name integer, intent(in) :: scn_nc integer input variable set to the total number of single cuts being considered in the oil integer, intent(in), allocatable :: scn (:) set of singles cuts being considered in the oil real(kind=pr), intent(in) :: plus_z composition of residual fraction from input file real(kind=pr), intent(in) :: a_blr input constant from the Best linear regression real(kind=pr), intent(in) :: b_blr input constant from the Best linear regression real(kind=pr), intent(in) :: half real(kind=pr), intent(out) :: a_60 output real variable. Slope of the limit line real(kind=pr), intent(out) :: b_60 output real variable. Intercept of the C60max line. integer, intent(out) :: c_max_60 output CN at which Zp is reached, as the summation of single z(i) from the Cmax60 distribution. Called by proc~~line_c60_max~2~~CalledByGraph proc~line_c60_max~2 Line_C60_max proc~difference_mw_plus~2 difference_mw_plus proc~difference_mw_plus~2->proc~line_c60_max~2 proc~get_c_or_m_plus get_C_or_m_plus proc~get_c_or_m_plus->proc~difference_mw_plus~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: F real(kind=pr), public :: F_tol real(kind=pr), public :: Zp_60 real(kind=pr), public :: a_old real(kind=pr), public :: a_tol real(kind=pr), public :: cross_cn real(kind=pr), public :: dF_dA real(kind=pr), public :: var_range integer, public :: x_aux real(kind=pr), public :: z_aux real(kind=pr), public :: z_cross real(kind=pr), public :: z_sum","tags":"","loc":"proc/line_c60_max~2.html"},{"title":"Linear_Regression – Forcha","text":"public  subroutine Linear_Regression(x, y, a, b, r2) This subroutine computes the regression line for a data set of x, y variables. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x (:) x: input array of length n which contains the set of independent variable real(kind=pr), intent(in) :: y (:) y: input array of length n which contains the set of dependent variable real(kind=pr), intent(out) :: a a: output real variable. Slope of the regression line real(kind=pr), intent(out) :: b b: output real variable. Intercept of the regression line real(kind=pr), intent(out) :: r2 Called by proc~~linear_regression~3~~CalledByGraph proc~linear_regression~3 Linear_Regression proc~best_linear_regression~3 Best_Linear_Regression proc~best_linear_regression~3->proc~linear_regression~3 proc~difference_mw_plus~2 difference_mw_plus proc~difference_mw_plus~2->proc~best_linear_regression~3 proc~get_c_or_m_plus get_C_or_m_plus proc~get_c_or_m_plus->proc~difference_mw_plus~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: aux1 real(kind=pr), public :: aux2 real(kind=pr), public :: aux3 real(kind=pr), public :: aux4 real(kind=pr), public :: aux5 integer, public :: i integer, public :: n total number of data set. real(kind=pr), public :: t1 real(kind=pr), public :: t2 real(kind=pr), public :: t3 real(kind=pr), public :: t4","tags":"","loc":"proc/linear_regression~3.html"},{"title":"difference_mw_plus – Forcha","text":"public  subroutine difference_mw_plus(oil, mw_source, method, start, C, difference, plus_mw) this subroutine …\nmayor igual a 12 o menor igual 14.\ndenominator of equation to obtain C value directly Arguments Type Intent Optional Attributes Name type( FluidData ) :: oil character(len=*), intent(in) :: mw_source character(len=*), intent(in), optional :: method logical :: start real(kind=pr) :: C C constants which is used in equation real(kind=pr), intent(out) :: difference real(kind=pr) :: plus_mw calculated molecular weight of  residual fraction Calls proc~~difference_mw_plus~2~~CallsGraph proc~difference_mw_plus~2 difference_mw_plus proc~best_linear_regression~3 Best_Linear_Regression proc~difference_mw_plus~2->proc~best_linear_regression~3 proc~limitline~3 LimitLine proc~difference_mw_plus~2->proc~limitline~3 proc~line_c60_max~2 Line_C60_max proc~difference_mw_plus~2->proc~line_c60_max~2 proc~select_method~2 select_method proc~difference_mw_plus~2->proc~select_method~2 proc~linear_regression~3 Linear_Regression proc~best_linear_regression~3->proc~linear_regression~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~difference_mw_plus~2~~CalledByGraph proc~difference_mw_plus~2 difference_mw_plus proc~get_c_or_m_plus get_C_or_m_plus proc~get_c_or_m_plus->proc~difference_mw_plus~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: a output real variable. Slope of the best regression line. real(kind=pr), public :: a_60 real(kind=pr), public :: a_best real(kind=pr), public :: a_blr real(kind=pr), public :: a_lim real(kind=pr), public :: a_old real(kind=pr), public :: b output real variable. Intercept of the best regression line. real(kind=pr), public :: b_60 real(kind=pr), public :: b_best real(kind=pr), public :: b_blr real(kind=pr), public :: b_lim real(kind=pr), public :: b_old integer, public :: c_max output CN at which plus_z is reached, as the summation of single z(i) from the best linear distribution (blr) integer, public :: c_max_60 integer, public :: c_max_blr integer, public :: c_max_lim integer, public, dimension(300) :: carbon_number_plus real(kind=pr), public :: denom real(kind=pr), public :: half integer, public :: i integer, public :: i_0 integer, public :: j integer, public :: k integer, public :: k_old real(kind=pr), public, allocatable :: log_scn_z (:) logarithm of corresponding mole fractions of scn cuts integer, public :: n_best integer, public :: n_init real(kind=pr), public :: plus_mw_cal calculated molecular weight of  residual fraction real(kind=pr), public :: plus_z composition of residual fraction from input file real(kind=pr), public, dimension(300) :: plus_z_i real(kind=pr), public, dimension(300) :: product_z_mw_plus_i real(kind=pr), public :: r2 output real variable. Square correlation coefficient. real(kind=pr), public :: r2_best real(kind=pr), public :: r2_old real(kind=pr), public, allocatable :: scn_mw (:) set to molecular weights calculated by real(kind=pr), public, allocatable :: scn_z (:) set of corresponding calculated mole fractions of scn cuts real(kind=pr), public :: sum_def_comp_z_plus compositions sum from (define component +1) to (plus component) real(kind=pr), public :: sum_z integer, public :: x_aux real(kind=pr), public, allocatable :: x_blr (:) real(kind=pr), public, allocatable :: y_blr (:) real(kind=pr), public :: z_aux real(kind=pr), public :: z_sum","tags":"","loc":"proc/difference_mw_plus~2.html"},{"title":"get_C_or_m_plus – Forcha","text":"public  subroutine get_C_or_m_plus(oil, mw_source, method, start, C) This subroutine… Arguments Type Intent Optional Attributes Name type( FluidData ) :: oil character(len=*), intent(in) :: mw_source character(len=*), intent(in), optional :: method logical :: start real(kind=pr) :: C C constants which is used in equation Calls proc~~get_c_or_m_plus~~CallsGraph proc~get_c_or_m_plus get_C_or_m_plus proc~difference_mw_plus~2 difference_mw_plus proc~get_c_or_m_plus->proc~difference_mw_plus~2 proc~best_linear_regression~3 Best_Linear_Regression proc~difference_mw_plus~2->proc~best_linear_regression~3 proc~limitline~3 LimitLine proc~difference_mw_plus~2->proc~limitline~3 proc~line_c60_max~2 Line_C60_max proc~difference_mw_plus~2->proc~line_c60_max~2 proc~select_method~2 select_method proc~difference_mw_plus~2->proc~select_method~2 proc~linear_regression~3 Linear_Regression proc~best_linear_regression~3->proc~linear_regression~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: C_old real(kind=pr), public :: aux integer, public :: c_max output CN at which plus_z is reached, as the summation of single z(i) from the best linear distribution (blr) real(kind=pr), public :: difference real(kind=pr), public :: difference_old real(kind=pr), public, allocatable :: log_scn_z (:) logarithm of corresponding mole fractions of scn cuts real(kind=pr), public :: plus_mw calculated molecular weight of  residual fraction real(kind=pr), public :: plus_mw_old real(kind=pr), public :: plus_z composition of residual fraction from input file","tags":"","loc":"proc/get_c_or_m_plus.html"},{"title":"select_method – Forcha","text":"public  subroutine select_method(oil, mw_source, method, C, log_scn_z, plus_z, plus_mw) Arguments Type Intent Optional Attributes Name type( FluidData ) :: oil character(len=*), intent(in) :: mw_source character(len=*), intent(in), optional :: method real(kind=pr) :: C C constants which is used in equation real(kind=pr), intent(out), allocatable :: log_scn_z (:) logarithm of corresponding mole fractions of scn cuts real(kind=pr), intent(out) :: plus_z composition of residual fraction from input file real(kind=pr) :: plus_mw calculated molecular weight of  residual fraction Called by proc~~select_method~2~~CalledByGraph proc~select_method~2 select_method proc~difference_mw_plus~2 difference_mw_plus proc~difference_mw_plus~2->proc~select_method~2 proc~get_c_or_m_plus get_C_or_m_plus proc~get_c_or_m_plus->proc~difference_mw_plus~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: def_comp_moles (:) real(kind=pr), public :: plus_moles real(kind=pr), public, allocatable :: scn_moles (:) real(kind=pr), public, allocatable :: scn_mw (:) set to molecular weights calculated by real(kind=pr), public, allocatable :: scn_z (:) set of corresponding calculated mole fractions of scn cuts real(kind=pr), public :: sum_def_comp_z_plus compositions sum from (define component +1) to (plus component) real(kind=pr), public :: total_moles","tags":"","loc":"proc/select_method~2.html"},{"title":"routines – Forcha","text":"Uses constants dtypes data_from_input module~~routines~~UsesGraph module~routines routines module~constants constants module~routines->module~constants module~data_from_input data_from_input module~routines->module~data_from_input module~dtypes dtypes module~routines->module~dtypes iso_fortran_env iso_fortran_env module~constants->iso_fortran_env module~data_from_input->module~constants module~data_from_input->module~dtypes module~dtypes->module~constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function characterize (file, mw_source, method, fix_C) result(characterization) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name character(len=*), intent(in) :: mw_source character(len=*), intent(in), optional :: method plus_mw or global_mw logical, intent(in), optional :: fix_C Return Value type( FluidDataOut ) Subroutines public  subroutine Best_Linear_Regression (scn_nc, scn, scn_z, plus_z, a, b, r2, n_init, c_max_blr) This subroutine calculates the best regression line for an fluid. Arguments Type Intent Optional Attributes Name integer, intent(in) :: scn_nc integer input variable set to the total number of single cuts being considered in the fluid integer, intent(in) :: scn (:) set of singles cuts being considered in the fluid real(kind=pr), intent(in) :: scn_z (:) set of corresponding mole fractions of scn cuts real(kind=pr), intent(in) :: plus_z composition of residual fraction from input file real(kind=pr), intent(out) :: a output real variable. Slope of the best regression line. real(kind=pr), intent(out) :: b output real variable. Intercept of the best regression line. real(kind=pr), intent(out) :: r2 output real variable. Square correlation coefficient. integer, intent(out) :: n_init minimum carbon number obtained from the best linear regression integer, intent(out) :: c_max_blr output CN at which plus_z is reached, as the summation of single z(i) from the best linear distribution (blr) public  subroutine LimitLine (scn_nc, scn, plus_z, a_blr, b_blr, a_lim, b_lim, c_max_lim, half) This subroutine obtains the limit line constants for an fluid. Arguments Type Intent Optional Attributes Name integer, intent(in) :: scn_nc integer input variable set to the total number of single cuts being considered in the fluid. integer, intent(in) :: scn (:) set of singles cuts being considered in the fluid. real(kind=pr), intent(in) :: plus_z composition of residual fraction from input file. real(kind=pr), intent(in) :: a_blr input constant from the Best linear regression. real(kind=pr), intent(in) :: b_blr input constant from the Best linear regression. real(kind=pr), intent(out) :: a_lim output real variable. Slope of the limit line. real(kind=pr), intent(out) :: b_lim output real variable. Intercept of the limit line. integer, intent(out) :: c_max_lim maximum carbon number obtained for limit line.\noutput CN at which plus_z is reached, as the summation of single z(i) from the limit distribution (blr). real(kind=pr), intent(out) :: half public  subroutine Line_C60_max (scn_nc, scn, plus_z, a_blr, b_blr, half, a_60, b_60, c_max_60) This subroutine obtains the Cmax60 line constants for an fluid. Arguments Type Intent Optional Attributes Name integer, intent(in) :: scn_nc integer input variable set to the total number of single cuts being considered in the fluid integer, intent(in) :: scn (:) set of singles cuts being considered in the fluid real(kind=pr), intent(in) :: plus_z composition of residual fraction from input file real(kind=pr), intent(in) :: a_blr input constant from the Best linear regression real(kind=pr), intent(in) :: b_blr input constant from the Best linear regression real(kind=pr), intent(in) :: half real(kind=pr), intent(out) :: a_60 output real variable. Slope of the limit line real(kind=pr), intent(out) :: b_60 output real variable. Intercept of the C60max line. integer, intent(out) :: c_max_60 output CN at which Zp is reached, as the summation of single z(i) from the Cmax60 distribution. public  subroutine Linear_Regression (x, y, a, b, r2) This subroutine computes the regression line for a data set of x, y variables. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x (:) x: input array of length n which contains the set of independent variable real(kind=pr), intent(in) :: y (:) y: input array of length n which contains the set of dependent variable real(kind=pr), intent(out) :: a a: output real variable. Slope of the regression line real(kind=pr), intent(out) :: b b: output real variable. Intercept of the regression line real(kind=pr), intent(out) :: r2 public  subroutine calculate_volume_6plus (fluid, mw_source, characterization) this subroutine … Arguments Type Intent Optional Attributes Name type( FluidData ), intent(in) :: fluid character(len=*), intent(in) :: mw_source type( FluidDataOut ), intent(inout) :: characterization public  subroutine density_funtion (fluid, mw_source, characterization) this subroutine … Arguments Type Intent Optional Attributes Name type( FluidData ) :: fluid character(len=*), intent(in) :: mw_source type( FluidDataOut ) :: characterization public  subroutine difference_mw_plus (fluid, mw_source, method, start, difference, characterization) this subroutine … Arguments Type Intent Optional Attributes Name type( FluidData ), intent(inout) :: fluid character(len=*), intent(in) :: mw_source character(len=*), intent(in), optional :: method logical :: start real(kind=pr), intent(out) :: difference type( FluidDataOut ), intent(inout) :: characterization public  subroutine get_c_or_m_plus (fluid, mw_source, method, fix_C, characterization) This subroutine… Arguments Type Intent Optional Attributes Name type( FluidData ) :: fluid character(len=*), intent(in) :: mw_source character(len=*), intent(in), optional :: method logical, intent(in) :: fix_C If C is < 12 or > 14 then fix to the\nclosest value. type( FluidDataOut ) :: characterization public  subroutine get_critical_constants (fluid, characterization) this subroutine .... Arguments Type Intent Optional Attributes Name type( FluidData ), intent(in) :: fluid type( FluidDataOut ), intent(inout) :: characterization public  subroutine lump (fluid, characterization) This sobroutine …\nuse new variable for plus_w because type fluidata can’t be modified.\nesto es lo que haria en el write, luego eliminar este comentario. Arguments Type Intent Optional Attributes Name type( FluidData ), intent(in) :: fluid type( FluidDataOut ), intent(inout) :: characterization public  subroutine select_method (fluid, mw_source, method, characterization) This subroutine defines the calculation method to perform the characterization,&\nbased on the available experimental data. If the molecular weight data is experimental,\ndefine the mole fractions, molecular weights and densities directly from the input file. \nOn the other hand, if the molecular weights are assumed, they are recalculated according \nto the methodology described by Martin et al and the molar fractions of the fluid are recalculated. Arguments Type Intent Optional Attributes Name type( FluidData ), intent(inout) :: fluid Derived type to save inlet or experimental information of fluid to be characterized. character(len=*), intent(in) :: mw_source This variable indicates the source of the input data, that is, whether they are experimental or not. character(len=*), intent(in), optional :: method this option allows choose beetwen obtaining plus_mw or global_mw reported in the experimental information . type( FluidDataOut ), intent(inout) :: characterization Derive type variable to save results of characterization methodology.","tags":"","loc":"module/routines.html"},{"title":"data – Forcha","text":"Uses constants module~~data~~UsesGraph module~data data module~constants constants module~data->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~data~~UsedByGraph module~data data module~routines_pre routines_pre module~routines_pre->module~data proc~difmpfromc difMpfromC proc~difmpfromc->module~data proc~difmpfromcfull difMpfromCfull proc~difmpfromcfull->module~data proc~difnewmp difnewMp proc~difnewmp->module~data Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Zplus integer, public :: nNcut integer, public :: nNdef integer, public :: nv integer, public :: nv1 Subroutines public  subroutine data_in (Nfluid, Oil, Ncut, Ndef, DefComp, zdef, rMdef, rCN, zcomp, rMW, Den, Plus, rMWplus, DenPlus, Nps, wat, watPlus, zM, zMp, Z6p, sumV, w, rn) Arguments Type Intent Optional Attributes Name integer :: Nfluid character(len=7) :: Oil integer :: Ncut integer :: Ndef character(len=4) :: DefComp (maxD) real(kind=pr), dimension(maxD) :: zdef real(kind=pr), dimension(maxD) :: rMdef integer, dimension(330) :: rCN real(kind=pr), dimension(imax) :: zcomp real(kind=pr), dimension(imax) :: rMW real(kind=pr), dimension(imax) :: Den character(len=7) :: Plus real(kind=pr) :: rMWplus real(kind=pr) :: DenPlus integer :: Nps real(kind=pr), dimension(imax) :: wat real(kind=pr) :: watPlus real(kind=pr), dimension(imax) :: zM real(kind=pr) :: zMp real(kind=pr) :: Z6p real(kind=pr) :: sumV real(kind=pr), dimension(imax) :: w real(kind=pr), dimension(imax) :: rn","tags":"","loc":"module/data.html"},{"title":"routines_pre – Forcha","text":"Uses constants data module~~routines_pre~~UsesGraph module~routines_pre routines_pre module~constants constants module~routines_pre->module~constants module~data data module~routines_pre->module~data iso_fortran_env iso_fortran_env module~constants->iso_fortran_env module~data->module~constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine Best_Linear_Regression (scn_nc, scn, scn_z, plus_z, a, b, r2, ninit) This subroutine calculates the best regression line for an oil. Arguments Type Intent Optional Attributes Name integer, intent(in) :: scn_nc integer input variable set to the total number of single cuts being considered in the oil integer, intent(in), allocatable :: scn (:) set of singles cuts being considered in the oil real, intent(in), allocatable :: scn_z (:) set of corresponding mole fractions of scn cuts real(kind=pr), intent(in) :: plus_z real(kind=pr), intent(out) :: a output real variable. Slope of the best regression line. real(kind=pr), intent(out) :: b output real variable. Intercept of the best regression line. real(kind=pr), intent(out) :: r2 output real variable. Square correlation coefficient. integer, intent(out) :: ninit minimum carbon number obtained from the best linear regression public  subroutine GetNewMpfromC (start, C, Ncut, rCN, zM, zMp, Z6p, a, b, rMp, maxC, z, zpi, zMpi, Ndef, zp, w, rn, rMWplus, zcomp, zdef, rMW, rMdef, Mglobal) this subroutines for a C value returns the correponding  new M20+ value Arguments Type Intent Optional Attributes Name logical :: start real(kind=pr) :: C integer :: Ncut integer, dimension(imax) :: rCN real(kind=pr), dimension(imax) :: zM real(kind=pr) :: zMp real(kind=pr) :: Z6p real(kind=pr) :: a real(kind=pr) :: b real(kind=pr) :: rMp integer :: maxC real(kind=pr), dimension(imax) :: z real(kind=pr), dimension(300) :: zpi real(kind=pr), dimension(300) :: zMpi integer :: Ndef real(kind=pr) :: zp real(kind=pr), dimension(imax) :: w real(kind=pr), dimension(imax) :: rn real(kind=pr) :: rMWplus real(kind=pr), dimension(imax) :: zcomp real(kind=pr), dimension(maxD) :: zdef real(kind=pr), dimension(imax) :: rMW real(kind=pr), dimension(maxD) :: rMdef real(kind=pr) :: Mglobal public  subroutine LimitLine (Ncut, rCN, Zp, aBE, bBE, half, alim, blim, Cmax) Arguments Type Intent Optional Attributes Name integer :: Ncut integer, dimension(imax) :: rCN real(kind=pr) :: Zp real(kind=pr) :: aBE real(kind=pr) :: bBE real(kind=pr) :: half real(kind=pr) :: alim real(kind=pr) :: blim integer :: Cmax public  subroutine LineC60max (Ncut, Zp, rCN, aBE, bBE, half, a60, b60, C60max) Arguments Type Intent Optional Attributes Name integer :: Ncut real(kind=pr) :: Zp integer, dimension(imax) :: rCN real(kind=pr) :: aBE real(kind=pr) :: bBE real(kind=pr) :: half real(kind=pr) :: a60 real(kind=pr) :: b60 integer :: C60max public  subroutine Linear_Regression (x, y, a, b, r2) This subroutine computes the regression line for a data set of x, y variables. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in), allocatable :: x (:) x: input array of length n which contains the set of independent variable real(kind=pr), intent(in), allocatable :: y (:) y: input array of length n which contains the set of dependent variable real(kind=pr), intent(out) :: a a: output real variable. Slope of the regression line real(kind=pr), intent(out) :: b b: output real variable. Intercept of the regression line real(kind=pr), intent(out) :: r2 public  subroutine difMpfromC (start, C, Ncut, rCN, zM, zMp, Z6p, dif, a, b, rMp, maxC, z, zpi, zMpi, zcomp, zdef, zp) Arguments Type Intent Optional Attributes Name logical :: start real(kind=pr) :: C integer :: Ncut integer, dimension(imax) :: rCN real(kind=pr), dimension(imax) :: zM real(kind=pr) :: zMp real(kind=pr) :: Z6p real(kind=pr) :: dif real(kind=pr) :: a real(kind=pr) :: b real(kind=pr) :: rMp integer :: maxC real(kind=pr), dimension(imax) :: z real(kind=pr), dimension(300) :: zpi real(kind=pr), dimension(300) :: zMpi real(kind=pr), dimension(imax) :: zcomp real(kind=pr), dimension(maxD) :: zdef real(kind=pr) :: zp public  subroutine difMpfromCfull (start, C, Ndef, Ncut, rCN, dif, a, b, rM, rMp, maxC, z, zp, zpi, zMpi, w, rn, zcomp, zdef) Arguments Type Intent Optional Attributes Name logical :: start real(kind=pr) :: C integer :: Ndef integer :: Ncut integer, dimension(imax) :: rCN real(kind=pr) :: dif real(kind=pr) :: a real(kind=pr) :: b real(kind=pr), dimension(imax) :: rM real(kind=pr) :: rMp integer :: maxC real(kind=pr), dimension(imax) :: z real(kind=pr) :: zp real(kind=pr), dimension(300) :: zpi real(kind=pr), dimension(300) :: zMpi real(kind=pr), dimension(imax) :: w real(kind=pr), dimension(imax) :: rn real(kind=pr), dimension(imax) :: zcomp real(kind=pr), dimension(maxD) :: zdef public  subroutine difnewMp (start, C, Ndef, Ncut, rCN, dif, a, b, rM, rMp, maxC, z, zp, zpi, zMpi, w, rn, zcomp, zdef, rMW, rMdef, Mglobal) this subroutines for a C value returns the correponding Mp value Arguments Type Intent Optional Attributes Name logical :: start real(kind=pr) :: C integer :: Ndef integer :: Ncut integer, dimension(imax) :: rCN real(kind=pr) :: dif real(kind=pr) :: a real(kind=pr) :: b real(kind=pr), dimension(imax) :: rM real(kind=pr) :: rMp integer :: maxC real(kind=pr), dimension(imax) :: z real(kind=pr) :: zp real(kind=pr), dimension(300) :: zpi real(kind=pr), dimension(300) :: zMpi real(kind=pr), dimension(imax) :: w real(kind=pr), dimension(imax) :: rn real(kind=pr), dimension(imax) :: zcomp real(kind=pr), dimension(maxD) :: zdef real(kind=pr), dimension(imax) :: rMW real(kind=pr), dimension(maxD) :: rMdef real(kind=pr) :: Mglobal public  subroutine get_C (start, C, Ncut, rCN, zM, zMp, Z6p, a, b, rMp, maxC, z, zpi, zMpi, Ndef, zp, w, rn, rMWplus, zcomp, zdef) Arguments Type Intent Optional Attributes Name logical :: start real(kind=pr) :: C integer :: Ncut integer, dimension(imax) :: rCN real(kind=pr), dimension(imax) :: zM real(kind=pr) :: zMp real(kind=pr) :: Z6p real(kind=pr) :: a real(kind=pr) :: b real(kind=pr) :: rMp integer :: maxC real(kind=pr), dimension(imax) :: z real(kind=pr), dimension(300) :: zpi real(kind=pr), dimension(300) :: zMpi integer :: Ndef real(kind=pr) :: zp real(kind=pr), dimension(imax) :: w real(kind=pr), dimension(imax) :: rn real(kind=pr) :: rMWplus real(kind=pr), dimension(imax) :: zcomp real(kind=pr), dimension(maxD) :: zdef","tags":"","loc":"module/routines_pre.html"},{"title":"data_from_input – Forcha","text":"This module reads the fluid information from the corresponding input file. Uses constants dtypes module~~data_from_input~~UsesGraph module~data_from_input data_from_input module~constants constants module~data_from_input->module~constants module~dtypes dtypes module~data_from_input->module~dtypes iso_fortran_env iso_fortran_env module~constants->iso_fortran_env module~dtypes->module~constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~data_from_input~~UsedByGraph module~data_from_input data_from_input module~pruebas pruebas module~pruebas->module~data_from_input module~routines routines module~routines->module~data_from_input Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function data_from_file (file) result(data) This funtion allows to obtain experimental data from data imput Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name Return Value type( FluidData ) Subroutines public  subroutine mass_fractions (file, w, product_z_mw_def_comp, product_z_mw_scn, sum_z_mw_i, product_z_mw_plus, def_comp_w, scn_w, plus_w) This routine obtains the mass fractions of the fluid’s compounds from\nthe input file, additionally, it calculates the product Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name real(kind=pr), intent(out), allocatable :: w (:) mass fractions of the fluid’s compounds real(kind=pr), intent(out), allocatable :: product_z_mw_def_comp (:) product between composition and molecular weight of defind components real(kind=pr), intent(out), allocatable :: product_z_mw_scn (:) product between composition and molecular weight of scn fractions real(kind=pr), intent(out) :: sum_z_mw_i sum of the product between composition and molecular weight of the fluid’s compounds real(kind=pr), intent(out) :: product_z_mw_plus product between composition and molecular weight of residual fraction real(kind=pr), intent(out), allocatable :: def_comp_w (:) real(kind=pr), intent(out), allocatable :: scn_w (:) real(kind=pr), intent(out) :: plus_w public  subroutine read_components (file, def_components, scn, scn_plus) Reads the component names data from input file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name character(len=15), intent(out), allocatable :: def_components (:) names of defined components integer, intent(out), allocatable :: scn (:) names of scn fractions character(len=15), intent(out) :: scn_plus name of residual fraction public  subroutine read_composition (file, def_comp_z, scn_z, plus_z) Reads the molar compositions of each component from input file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name real(kind=pr), intent(out), allocatable :: def_comp_z (:) set of corresponding mole fractions of defined components real(kind=pr), intent(out), allocatable :: scn_z (:) set of corresponding mole fractions of scn cuts real(kind=pr), intent(out) :: plus_z composition of residual fraction from input file public  subroutine read_density (file, scn_density, plus_density) Reads the density of each component from the input file and calculated molar volume since C6 fraction. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name real(kind=pr), intent(out), allocatable :: scn_density (:) set of corresponding densities of scn cuts real(kind=pr), intent(out) :: plus_density density of residual fraction from input file public  subroutine read_molecular_weight (file, def_comp_mw, scn_mw, plus_mw) Reads the molecular weights of each component from the input file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name real(kind=pr), intent(out), allocatable :: def_comp_mw (:) set of corresponding molecular weights of defined components real(kind=pr), intent(out), allocatable :: scn_mw (:) set of corresponding molecular weights of scn cuts real(kind=pr), intent(out) :: plus_mw molecular weight of residual fraction public  subroutine read_setup (file, def_comp_nc, scn_nc, scn_nc_ps, numbers_ps) Reads the setup data from input file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file file name integer, intent(out) :: def_comp_nc number of defined components being considered in the oil integer, intent(out) :: scn_nc number of single cuts being considered in the oil integer, intent(out) :: scn_nc_ps CN from which all SCN fractions will be lumped into the specified number of pseudos integer, intent(out) :: numbers_ps number of pseudos in which the scn fractions grouped","tags":"","loc":"module/data_from_input.html"},{"title":"dtypes – Forcha","text":"Uses constants module~~dtypes~~UsesGraph module~dtypes dtypes module~constants constants module~dtypes->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~dtypes~~UsedByGraph module~dtypes dtypes module~data_from_input data_from_input module~data_from_input->module~dtypes module~routines routines module~routines->module~dtypes module~routines->module~data_from_input module~pruebas pruebas module~pruebas->module~data_from_input Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: FluidData Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: def_comp_mw (:) set of corresponding molecular weights of defined components integer, public :: def_comp_nc number of defined components being considered in the oil real(kind=pr), public, allocatable :: def_comp_w (:) mass fractions of the defined compounds real(kind=pr), public, allocatable :: def_comp_z (:) set of corresponding mole fractions of defined components character(len=15), public, allocatable :: def_components (:) set of defined components being considered in the oil character(len=:), public, allocatable :: filename integer, public :: numbers_ps number of pseudos in which the scn fractions grouped. real(kind=pr), public :: plus_density experimental density of the plus fraction real(kind=pr), public :: plus_mw molecular weight of residual fraction real(kind=pr), public :: plus_w mass fractions of the plus fraction real(kind=pr), public :: plus_z composition of residual fraction real(kind=pr), public, allocatable :: product_z_mw_def_comp (:) product between composition and molecular weight of defind components real(kind=pr), public :: product_z_mw_plus product between composition and molecular weight of residual fraction real(kind=pr), public, allocatable :: product_z_mw_scn (:) product between composition and molecular weight of scn fractions integer, public, allocatable :: scn (:) set of singles cuts being considered in the oil real(kind=pr), public, allocatable :: scn_density (:) set of corresponding densities of scn cuts real(kind=pr), public, allocatable :: scn_mw (:) set of corresponding molecular weights of scn cuts integer, public :: scn_nc number of single cuts being considered in the oil integer, public :: scn_nc_ps CN from which all SCN fractions will be lumped into the specified number of pseudos character(len=15), public :: scn_plus name of residual fraction real(kind=pr), public, allocatable :: scn_w (:) !! mass fractions of the scn-s compounds real(kind=pr), public, allocatable :: scn_z (:) set of corresponding mole fractions of scn cuts real(kind=pr), public :: sum_z_mw_i sum of the product between composition and molecular weight of the fluid’s compounds real(kind=pr), public, allocatable :: w (:) mass fractions of the fluid’s compounds type, public :: FluidDataOut Components Type Visibility Attributes Name Initial real(kind=pr), public :: C C constants which is used in equation real(kind=pr), public :: a output real variable. Slope of the best feasible regression line. real(kind=pr), public :: a_60 A constant for Cmax60 line. real(kind=pr), public :: a_blr A constant for best linear regression line. real(kind=pr), public :: a_d ad constant which is used in equation for density. real(kind=pr), public :: a_lim A constant for limit feasible line. real(kind=pr), public :: b output real variable. Intercept of the best feasible regression line. real(kind=pr), public :: b_60 B constant for Cmax60 line. real(kind=pr), public :: b_blr B constant for best linear regression line. real(kind=pr), public :: b_d bd constant which is used in equation for density. real(kind=pr), public :: b_lim B constant for limit feasible line. integer, public :: c_max output CN at which plus_z is reached, as the summation of single z(i) from the best linear distribution (blr) integer, public :: c_max_60 integer, public :: c_max_blr integer, public :: c_max_lim real(kind=pr), public, allocatable :: carbon_number_plus (:) integer, public :: i_last integer, public :: last_C real(kind=pr), public, allocatable :: log_scn_z (:) set of corresponding mole fractions of scn cuts calculated integer, public :: n_init integer, public :: nc_plus number of elements in the distribution of C20+ real(kind=pr), public, allocatable :: plus6_density (:) real(kind=pr), public :: plus_mw molecular weight of residual fraction real(kind=pr), public :: plus_w real(kind=pr), public :: plus_z composition of residual fraction real(kind=pr), public, allocatable :: plus_z_i (:) real(kind=pr), public :: plus_zm real(kind=pr), public, allocatable :: product_z_mw_plus_i (:) real(kind=pr), public :: r2 output real variable. Square correlation coefficient. real(kind=pr), public, allocatable :: scn_i (:) real(kind=pr), public, allocatable :: scn_mw (:) set of corresponding molecular weights of scn cuts real(kind=pr), public, allocatable :: scn_z (:) set of corresponding mole fractions of scn cuts calculated real(kind=pr), public, allocatable :: scn_zm (:) real(kind=pr), public :: volume_6plus_cal","tags":"","loc":"module/dtypes.html"},{"title":"constants – Forcha","text":"Uses iso_fortran_env module~~constants~~UsesGraph module~constants constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~constants~~UsedByGraph module~constants constants module~data data module~data->module~constants module~data_from_input data_from_input module~data_from_input->module~constants module~dtypes dtypes module~data_from_input->module~dtypes module~dtypes->module~constants module~pruebas pruebas module~pruebas->module~constants module~pruebas->module~data_from_input module~routines routines module~routines->module~constants module~routines->module~data_from_input module~routines->module~dtypes module~routines_pre routines_pre module~routines_pre->module~constants module~routines_pre->module~data proc~difmpfromc difMpfromC proc~difmpfromc->module~data proc~difmpfromcfull difMpfromCfull proc~difmpfromcfull->module~data proc~difnewmp difnewMp proc~difnewmp->module~data Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: pr = real64","tags":"","loc":"module/constants.html"},{"title":"pruebas – Forcha","text":"Uses constants data_from_input module~~pruebas~~UsesGraph module~pruebas pruebas module~constants constants module~pruebas->module~constants module~data_from_input data_from_input module~pruebas->module~data_from_input iso_fortran_env iso_fortran_env module~constants->iso_fortran_env module~data_from_input->module~constants module~dtypes dtypes module~data_from_input->module~dtypes module~dtypes->module~constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine Best_Linear_Regression (scn_nc, scn, scn_z, plus_z, a, b, r2, n_init, c_max_blr) This subroutine calculates the best regression line for an oil. Arguments Type Intent Optional Attributes Name integer, intent(in) :: scn_nc integer input variable set to the total number of single cuts being considered in the oil integer, intent(in), allocatable :: scn (:) set of singles cuts being considered in the oil real(kind=pr), intent(in), allocatable :: scn_z (:) set of corresponding mole fractions of scn cuts real(kind=pr), intent(in) :: plus_z composition of residual fraction from input file real(kind=pr), intent(out) :: a output real variable. Slope of the best regression line. real(kind=pr), intent(out) :: b output real variable. Intercept of the best regression line. real(kind=pr), intent(out) :: r2 output real variable. Square correlation coefficient. integer, intent(out) :: n_init minimum carbon number obtained from the best linear regression integer, intent(out) :: c_max_blr output CN at which plus_z is reached, as the summation of single z(i) from the best linear distribution (blr) public  subroutine LimitLine (scn_nc, scn, plus_z, a_blr, b_blr, a_lim, b_lim, c_max_lim, half) This subroutine obtains the limit line constants for an oil. Arguments Type Intent Optional Attributes Name integer, intent(in) :: scn_nc integer input variable set to the total number of single cuts being considered in the oil integer, intent(in), allocatable :: scn (:) set of singles cuts being considered in the oil real(kind=pr), intent(in) :: plus_z composition of residual fraction from input file real(kind=pr), intent(in) :: a_blr input constant from the Best linear regression real(kind=pr), intent(in) :: b_blr input constant from the Best linear regression real(kind=pr), intent(out) :: a_lim output real variable. Slope of the limit line real(kind=pr), intent(out) :: b_lim output real variable. Intercept of the limit line. integer, intent(out) :: c_max_lim output CN at which plus_z is reached, as the summation of single z(i) from the limit distribution (blr) real(kind=pr), intent(out) :: half public  subroutine Line_C60_max (scn_nc, scn, plus_z, a_blr, b_blr, half, a_60, b_60, c_max_60) This subroutine obtains the Cmax60 line constants for an oil Arguments Type Intent Optional Attributes Name integer, intent(in) :: scn_nc integer input variable set to the total number of single cuts being considered in the oil integer, intent(in), allocatable :: scn (:) set of singles cuts being considered in the oil real(kind=pr), intent(in) :: plus_z composition of residual fraction from input file real(kind=pr), intent(in) :: a_blr input constant from the Best linear regression real(kind=pr), intent(in) :: b_blr input constant from the Best linear regression real(kind=pr), intent(in) :: half real(kind=pr), intent(out) :: a_60 output real variable. Slope of the limit line real(kind=pr), intent(out) :: b_60 output real variable. Intercept of the C60max line. integer, intent(out) :: c_max_60 output CN at which Zp is reached, as the summation of single z(i) from the Cmax60 distribution. public  subroutine Linear_Regression (x, y, a, b, r2) This subroutine computes the regression line for a data set of x, y variables. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x (:) x: input array of length n which contains the set of independent variable real(kind=pr), intent(in) :: y (:) y: input array of length n which contains the set of dependent variable real(kind=pr), intent(out) :: a a: output real variable. Slope of the regression line real(kind=pr), intent(out) :: b b: output real variable. Intercept of the regression line real(kind=pr), intent(out) :: r2 public  subroutine difference_mw_plus (oil, mw_source, method, start, C, difference, plus_mw) this subroutine …\nmayor igual a 12 o menor igual 14.\ndenominator of equation to obtain C value directly Arguments Type Intent Optional Attributes Name type( FluidData ) :: oil character(len=*), intent(in) :: mw_source character(len=*), intent(in), optional :: method logical :: start real(kind=pr) :: C C constants which is used in equation real(kind=pr), intent(out) :: difference real(kind=pr) :: plus_mw calculated molecular weight of  residual fraction public  subroutine get_C_or_m_plus (oil, mw_source, method, start, C) This subroutine… Arguments Type Intent Optional Attributes Name type( FluidData ) :: oil character(len=*), intent(in) :: mw_source character(len=*), intent(in), optional :: method logical :: start real(kind=pr) :: C C constants which is used in equation public  subroutine select_method (oil, mw_source, method, C, log_scn_z, plus_z, plus_mw) Arguments Type Intent Optional Attributes Name type( FluidData ) :: oil character(len=*), intent(in) :: mw_source character(len=*), intent(in), optional :: method real(kind=pr) :: C C constants which is used in equation real(kind=pr), intent(out), allocatable :: log_scn_z (:) logarithm of corresponding mole fractions of scn cuts real(kind=pr), intent(out) :: plus_z composition of residual fraction from input file real(kind=pr) :: plus_mw calculated molecular weight of  residual fraction","tags":"","loc":"module/pruebas.html"},{"title":"  nml_setup – Forcha\n","text":"Variables Name Type Default Description def_comp_nc integer None number of defined components being considered in the oil scn_nc integer None number of single cuts being considered in the oil scn_nc_ps integer None CN from which all SCN fractions will be lumped into the specified number of pseudos numbers_ps integer None number of pseudos in which the scn fractions grouped","tags":"","loc":"namelist/nml_setup.html"},{"title":"  nml_components – Forcha\n","text":"Variables Name Type Default Description def_components character(len=15) None names of defined components scn integer None names of scn fractions scn_plus character(len=15) None name of residual fraction","tags":"","loc":"namelist/nml_components.html"},{"title":"  nml_composition – Forcha\n","text":"Variables Name Type Default Description def_comp_z real(kind=pr) None set of corresponding mole fractions of defined components scn_z real(kind=pr) None set of corresponding mole fractions of scn cuts plus_z real(kind=pr) None composition of residual fraction from input file","tags":"","loc":"namelist/nml_composition.html"},{"title":"  nml_molecular_weight – Forcha\n","text":"Variables Name Type Default Description def_comp_mw real(kind=pr) None set of corresponding molecular weights of defined components scn_mw real(kind=pr) None set of corresponding molecular weights of scn cuts plus_mw real(kind=pr) None molecular weight of residual fraction","tags":"","loc":"namelist/nml_molecular_weight.html"},{"title":"  nml_density – Forcha\n","text":"Variables Name Type Default Description scn_density real(kind=pr) None set of corresponding densities of scn cuts plus_density real(kind=pr) None density of residual fraction from input file","tags":"","loc":"namelist/nml_density.html"},{"title":"routines.f90 – Forcha","text":"This file depends on sourcefile~~routines.f90~~EfferentGraph sourcefile~routines.f90 routines.f90 sourcefile~constans.f90 constans.f90 sourcefile~routines.f90->sourcefile~constans.f90 sourcefile~data_input.f90 data_input.f90 sourcefile~routines.f90->sourcefile~data_input.f90 sourcefile~types.f90 types.f90 sourcefile~routines.f90->sourcefile~types.f90 sourcefile~data_input.f90->sourcefile~constans.f90 sourcefile~data_input.f90->sourcefile~types.f90 sourcefile~types.f90->sourcefile~constans.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module routines use constants use dtypes , only : FluidData , FluidDataOut use data_from_input , only : data_from_file , FluidData contains subroutine Linear_Regression ( x , y , a , b , r2 ) !! This subroutine computes the regression line for a data set of x, y variables. implicit none integer :: i integer :: n !! total number of data set. real ( pr ), intent ( in ) :: x (:) !! x: input array of length n which contains the set of independent variable real ( pr ), intent ( in ) :: y (:) !! y: input array of length n which contains the set of dependent variable real ( pr ) :: t1 , t2 , t3 , t4 , aux1 , aux2 , aux3 , aux4 , aux5 ! internal variables real ( pr ), intent ( out ) :: a !! a: output real variable. Slope of the regression line real ( pr ), intent ( out ) :: b !! b: output real variable. Intercept of the regression line real ( pr ), intent ( out ) :: r2 !! r2: output real variable. Square correlation coefficient n = size ( x ) !Calculation of a y b --> y=a*x+b t1 = 0. ; t2 = 0. ; t3 = 0. ; t4 = 0. ; do i = 1 , n t1 = t1 + x ( i ) * y ( i ) t2 = t2 + x ( i ) t3 = t3 + y ( i ) t4 = t4 + x ( i ) ** 2 end do a = ( n * t1 - t2 * t3 ) / ( n * t4 - t2 ** 2 ) b = ( t3 - a * t2 ) / n !coefficient calculation of correlations r2 aux1 = 0. ; aux2 = 0. ; aux3 = 0. ; aux4 = 0. ; aux5 = 0. ; do i = 1 , n aux1 = aux1 + x ( i ) * y ( i ) aux2 = aux2 + x ( i ) aux3 = aux3 + y ( i ) aux4 = aux4 + x ( i ) ** 2 aux5 = aux5 + y ( i ) ** 2 end do r2 = ( aux1 - aux2 * aux3 / n ) ** 2 / (( aux4 - aux2 ** 2 / n ) * ( aux5 - aux3 ** 2 / n )) end subroutine Linear_Regression subroutine Best_Linear_Regression ( scn_nc , scn , scn_z , plus_z , a , b , r2 , & n_init , c_max_blr ) !! This subroutine calculates the best regression line for an fluid. implicit none integer , intent ( in ) :: scn_nc !! integer input variable set to the total number of single cuts being considered in the fluid integer , intent ( in ) :: scn (:) !! set of singles cuts being considered in the fluid integer , intent ( out ) :: c_max_blr !! output CN at which plus_z is reached, as the summation of single z(i) from the best linear distribution (blr) real ( pr ), intent ( in ) :: scn_z (:) !! set of corresponding mole fractions of scn cuts real ( pr ), intent ( in ) :: plus_z !! composition of residual fraction from input file real ( pr ), intent ( out ) :: a !! output real variable. Slope of the best regression line. real ( pr ), intent ( out ) :: b !! output real variable. Intercept of the best regression line. real ( pr ), intent ( out ) :: r2 !! output real variable. Square correlation coefficient. integer , intent ( out ) :: n_init !! minimum carbon number obtained from the best linear regression integer :: i , j , k , k_old , n_best , x_aux ! internal variables real ( pr ), dimension ( scn_nc ) :: x_blr , y_blr ! x_blr: carbon number vector, y_blr: logarithm of mole fraction vector; for each step real ( pr ) :: r2_old , r2_best , a_old , b_old , a_best , b_best , z_sum , z_aux ! auxiliary variables k = 5 r2 = 0.0001_pr r2_old = 0.00001_pr r2_best = 0.0001_pr do while ( r2 . gt . r2_old . or . r2_old . lt . 0.9 ) k_old = k r2_old = r2 a_old = a b_old = b if ( r2 . gt . r2_best ) then r2_best = r2 a_best = a b_best = b n_best = scn ( scn_nc - k + 2 ) end if if ( k . gt . scn_nc ) then if ( r2 . gt . r2_best ) then n_init = scn ( scn_nc - k + 2 ) go to 22 else r2 = r2_best a = a_best b = b_best n_init = n_best go to 22 end if end if j = 1 x_blr = 0. y_blr = 0. do i = scn_nc - k + 1 , scn_nc x_blr ( j ) = scn ( i ) y_blr ( j ) = scn_z ( i ) j = j + 1 end do call Linear_Regression ( x_blr (: k ), y_blr (: k ), a , b , r2 ) k = k + 1 end do r2 = r2_old a = a_old b = b_old n_init = scn ( scn_nc - k_old + 2 ) 22 continue z_sum = 0 d0 x_aux = scn ( scn_nc ) do while ( z_sum . lt . plus_z . and . x_aux < 300 ) x_aux = x_aux + 1 z_aux = exp ( a * x_aux + b ) z_sum = z_sum + z_aux end do c_max_blr = x_aux !print*, a, b, c_max_blr, r2, n_init end subroutine Best_Linear_Regression subroutine LimitLine ( scn_nc , scn , plus_z , a_blr , b_blr , a_lim , b_lim , & c_max_lim , half ) !! This subroutine obtains the limit line constants for an fluid. implicit none integer , intent ( in ) :: scn_nc !! integer input variable set to the total number of single cuts being considered in the fluid. integer , intent ( in ) :: scn (:) !! set of singles cuts being considered in the fluid. integer , intent ( out ) :: c_max_lim !! maximum carbon number obtained for limit line. !! output CN at which plus_z is reached, as the summation of single z(i) from the limit distribution (blr). real ( pr ), intent ( in ) :: a_blr !! input constant from the Best linear regression. real ( pr ), intent ( in ) :: b_blr !! input constant from the Best linear regression. real ( pr ), intent ( in ) :: plus_z !! composition of residual fraction from input file. real ( pr ), intent ( out ) :: a_lim !! output real variable. Slope of the limit line. real ( pr ), intent ( out ) :: b_lim !! output real variable. Intercept of the limit line. real ( pr ), intent ( out ) :: half ! variable defined in the numerical method to converge the area under the curve of the function. real ( pr ) :: z_lim , cross_cn , z_cross , z_aux integer :: x_aux ! internal variable !A and B limit calculation. z_lim = 0.0_pr half = 0.506_pr ! modified by oscar, the variable half was removed from the argument do while ( z_lim . lt . plus_z ) half = half + 0.002d0 cross_cn = scn ( scn_nc ) + half ! typically 19.508 in first try z_cross = exp (( a_blr * cross_cn ) + b_blr ) a_lim = - ( z_cross ) / plus_z b_lim = log ( z_cross ) - ( a_lim * cross_cn ) x_aux = scn ( scn_nc ) z_lim = 0._pr do while ( z_lim . lt . plus_z . and . x_aux < 300 ) x_aux = x_aux + 1 z_aux = exp ( a_lim * x_aux + b_lim ) z_lim = z_lim + z_aux end do continue end do c_max_lim = x_aux end subroutine LimitLine subroutine Line_C60_max ( scn_nc , scn , plus_z , a_blr , b_blr , half , a_60 , & b_60 , c_max_60 ) !! This subroutine obtains the Cmax60 line constants for an fluid. implicit none integer , intent ( in ) :: scn_nc !! integer input variable set to the total number of single cuts being considered in the fluid integer , intent ( in ) :: scn (:) !! set of singles cuts being considered in the fluid integer , intent ( out ) :: c_max_60 !!output CN at which Zp is reached, as the summation of single z(i) from the Cmax60 distribution. real ( pr ), intent ( in ) :: a_blr !! input constant from the Best linear regression real ( pr ), intent ( in ) :: b_blr !! input constant from the Best linear regression real ( pr ), intent ( in ) :: plus_z !! composition of residual fraction from input file real ( pr ), intent ( out ) :: a_60 !! output real variable. Slope of the limit line real ( pr ), intent ( out ) :: b_60 !! output real variable. Intercept of the C60max line. real ( pr ), intent ( in ) :: half !variable defined in the numerical method to converge the area under the curve of the function integer :: x_aux ! auxiliary variable real ( pr ) :: z_sum , cross_cn , z_cross , z_aux , F_tol , a_tol , var_range ! internal variables real ( pr ) :: a_old , Zp_60 , F , dF_dA ! internal variables cross_cn = scn ( scn_nc ) + half ! typically 19.51 z_cross = exp (( a_blr * cross_cn ) + b_blr ) F_tol = 1_pr a_tol = 1_pr a_60 = a_blr var_range = 6 0.5_pr - cross_cn do while ( a_tol . gt . 1e-6_pr . or . F_tol . gt . 1e-6_pr ) a_old = a_60 Zp_60 = ( exp ( a_60 * var_range + log ( z_cross )) - z_cross ) / a_60 F = plus_z - Zp_60 dF_dA = - ( var_range * ( a_60 * Zp_60 + z_cross ) - Zp_60 ) / a_60 ! modified by oscar, error in the derivative in previous version is corrected a_60 = a_old - ( F / dF_dA ) a_tol = abs ( a_old - a_60 ) F_tol = abs ( F ) end do b_60 = log ( z_cross ) - a_60 * cross_cn z_sum = 0.0_pr x_aux = scn ( scn_nc ) do while ( z_sum . lt . plus_z ) x_aux = x_aux + 1 z_aux = exp ( a_60 * x_aux + b_60 ) z_sum = z_sum + z_aux end do c_max_60 = x_aux !print*, a_60,b_60,c_max_60 end subroutine Line_C60_max subroutine select_method ( fluid , mw_source , method , characterization ) !! This subroutine defines the calculation method to perform the characterization,& !! based on the available experimental data. If the molecular weight data is experimental, !! define the mole fractions, molecular weights and densities directly from the input file. !! On the other hand, if the molecular weights are assumed, they are recalculated according !! to the methodology described by Martin et al and the molar fractions of the fluid are recalculated. implicit none type ( FluidData ), intent ( inout ) :: fluid !! Derived type to save inlet or experimental information of fluid to be characterized. type ( FluidDataOut ), intent ( inout ) :: characterization !! Derive type variable to save results of characterization methodology. character ( len =* ), intent ( in ), optional :: method !! this option allows choose beetwen obtaining plus_mw or global_mw reported in the experimental information . character ( len =* ), intent ( in ) :: mw_source !! This variable indicates the source of the input data, that is, whether they are experimental or not. real ( pr ) :: sum_def_comp_z_plus !! compositions sum from (define component +1) to (plus component) real ( pr ), allocatable :: def_comp_moles (:) !! real ( pr ), allocatable :: scn_moles (:) !! real ( pr ) :: plus_moles real ( pr ) :: total_moles associate (& scn_nc => fluid % scn_nc , def_comp_nc => fluid % def_comp_nc , & def_comp_w => fluid % def_comp_w , def_comp_mw => fluid % def_comp_mw , & scn_w => fluid % scn_w , plus_w => fluid % plus_w , scn => fluid % scn , & plus_mw => characterization % plus_mw , scn_z => characterization % scn_z , & plus_z => characterization % plus_z , log_scn_z => characterization % log_scn_z , & C => characterization % C , scn_mw => characterization % scn_mw , & scn_zm => characterization % scn_zm , & plus_zm => characterization % plus_zm & ) allocate ( def_comp_moles ( def_comp_nc )) allocate ( scn_moles ( scn_nc )) def_comp_moles = ( def_comp_w ) / ( def_comp_mw ) select case ( mw_source ) case ( \"experimental\" ) scn_mw = fluid % scn_mw scn_moles = ( scn_w ) / ( scn_mw ) plus_moles = ( plus_w ) / ( plus_mw ) total_moles = sum ( def_comp_moles ) + sum ( scn_moles ) + ( plus_moles ) scn_z = scn_moles / total_moles plus_z = plus_moles / total_moles case ( \"calculated\" ) if ( method == \"global_mw\" ) then scn_mw = 84 + C * ( scn - 6 ) scn_z = fluid % product_z_mw_scn / scn_mw sum_def_comp_z_plus = sum ( fluid % scn_z ) + ( fluid % plus_z ) plus_z = sum_def_comp_z_plus - sum ( scn_z ) ! new molar fraction for residual cut, based on C plus_mw = fluid % product_z_mw_plus / plus_z end if if ( method == \"plus_mw\" ) then scn_mw = 84 + C * ( scn - 6 ) scn_moles = ( scn_w ) / ( scn_mw ) plus_moles = ( plus_w ) / ( plus_mw ) total_moles = sum ( def_comp_moles ) + sum ( scn_moles ) + ( plus_moles ) scn_z = scn_moles / total_moles plus_z = plus_moles / total_moles endif end select scn_zm = scn_z * scn_mw plus_zm = plus_z * plus_mw log_scn_z = log ( scn_z ) end associate end subroutine select_method subroutine difference_mw_plus ( fluid , mw_source , method , start , difference , & characterization ) !! this subroutine ... implicit none type ( FluidData ), intent ( inout ) :: fluid type ( FluidDataOut ), intent ( inout ) :: characterization logical :: start character ( len =* ), intent ( in ), optional :: method character ( len =* ), intent ( in ) :: mw_source real ( pr ) :: plus_mw_cal !!  calculated molecular weight of  residual fraction real ( pr ), intent ( out ) :: difference real ( pr ) :: half real ( pr ) :: r2_old , r2_best , a_old , b_old , a_best , b_best , z_sum , z_aux real ( pr ) :: sum_z real ( pr ) :: denom !! set to molecular weights calculated by M = 84-characterization%C(i-6) real ( pr ) :: sum_def_comp_z_plus !! compositions sum from (define component +1) to (plus component) integer :: j , k , k_old , n_best , x_aux , i_0 ! internal variables integer :: i integer , dimension ( 300 ) :: carbon_number_plus real ( pr ), dimension ( 300 ) :: plus_z_i real ( pr ), dimension ( 300 ) :: product_z_mw_plus_i real ( pr ), dimension ( 300 ) :: scn_i associate (& scn_nc => fluid % scn_nc , scn => fluid % scn ,& plus_z => characterization % plus_z , plus_mw => characterization % plus_mw , & log_scn_z => characterization % log_scn_z , C => characterization % C , & a_blr => characterization % a_blr , b_blr => characterization % b_blr , & a_60 => characterization % a_60 , b_60 => characterization % b_60 , & a_lim => characterization % a_lim , b_lim => characterization % b_lim , & r2 => characterization % r2 , n_init => characterization % n_init , & c_max_blr => characterization % c_max_lim , a => characterization % a , & c_max_lim => characterization % c_max_lim , b => characterization % b , & c_max_60 => characterization % c_max_lim , & c_max => characterization % c_max & ) 1 i_0 = scn ( scn_nc ) call select_method ( fluid , mw_source , method , characterization ) ! select case call Best_Linear_Regression ( scn_nc , scn , log_scn_z , & plus_z , a_blr , b_blr , r2 , n_init , c_max_blr ) call LimitLine ( scn_nc , scn , plus_z , a_blr , b_blr , a_lim , b_lim , c_max_lim , half ) call Line_C60_max ( scn_nc , scn , plus_z , a_blr , b_blr , half , a_60 , b_60 , c_max_60 ) ! add line by oscar. if ( a_blr < a_lim ) then !Added by oscar 05/12/2023.se elimina por que se agregan las restricciones !para characterization%C>12 y characterization%C<12. a = a_lim b = b_lim else ! this line was removed call Line_C60_max if ( a_blr > a_60 ) then a = a_60 b = b_60 else a = a_blr b = b_blr end if end if sum_z = 0.0_pr i = 0 do while ( sum_z < plus_z . and . i < 300 ) i = i + 1 plus_z_i ( i ) = exp ( a * ( i + i_0 ) + b ) sum_z = sum_z + plus_z_i ( i ) product_z_mw_plus_i ( i ) = plus_z_i ( i ) * ( 84 + C * ( i + i_0 - 6 )) carbon_number_plus ( i ) = i + i_0 end do if ( i == 30 0. and . sum_z < plus_z ) then if ( start ) C = C - 0.07 if (. not . start ) C = C - 0.01 go to 1 end if c_max = i + i_0 plus_z_i ( i ) = plus_z_i ( i ) - ( sum_z - plus_z ) !   Adjustment to Zp (z20+) product_z_mw_plus_i ( i ) = plus_z_i ( i ) * ( 84 + C * ( i + i_0 - 6 )) if ( mw_source == \"experimental\" . and . C > 12 . and . C < 14 ) then ! mayor igual a 12 o menor igual 14. denom = sum (( plus_z_i ( 1 : i )) * (( carbon_number_plus ( 1 : i ) - 6 ))) ! denominator of equation to obtain C value directly C = ( plus_z * ( plus_mw - 84 )) / denom endif plus_mw_cal = sum ( product_z_mw_plus_i ( 1 : i )) / plus_z difference = plus_mw_cal - plus_mw scn_i = [ scn , carbon_number_plus ( 1 : i )] end associate characterization % plus_z_i = plus_z_i ( 1 : i ) characterization % product_z_mw_plus_i = product_z_mw_plus_i ( 1 : i ) characterization % carbon_number_plus = carbon_number_plus ( 1 : i ) characterization % nc_plus = i characterization % scn_i = scn_i end subroutine difference_mw_plus subroutine get_c_or_m_plus ( fluid , mw_source , method , fix_C , characterization ) !! This subroutine... implicit none type ( FluidData ) :: fluid type ( FluidDataOut ) :: characterization logical :: start character ( len =* ), intent ( in ) :: mw_source character ( len =* ), intent ( in ), optional :: method logical , intent ( in ) :: fix_C !! If C is < 12 or > 14 then fix to the !! closest value. !integer :: c_max !! output CN at which characterization%plus_z is reached, as the summation of single z(i) from the best linear distribution (blr) real ( pr ), allocatable :: log_scn_z (:) !! logarithm of corresponding mole fractions of scn cutsn real ( pr ) :: difference !! real ( pr ) :: difference_old , plus_mw_old real ( pr ) :: C_old real ( pr ) :: aux associate ( C => characterization % C , plus_mw => characterization % plus_mw ) select case ( mw_source ) case ( \"experimental\" ) C = 1 3.5 Start = . true . plus_mw = fluid % plus_mw call difference_mw_plus ( fluid , mw_source , method , start , difference , & characterization ) case ( \"calculated\" ) if ( method == 'global_mw' ) C = 13 if ( method == 'plus_mw' ) C = 14 Start = . true . plus_mw = fluid % plus_mw call difference_mw_plus ( fluid , mw_source , method , start , & difference_old , characterization ) C_old = C if ( method == 'global_mw' ) C = min ( 1 2.8 , C - 0.07 ) if ( method == 'plus_mw' ) C = 1 3.5 Start = . false . call difference_mw_plus ( fluid , mw_source , method , start , difference , & characterization ) do while ( abs ( difference ) > 0.1 ) aux = C C = C - difference * ( C - C_old ) / ( difference - difference_old ) C_old = aux difference_old = difference call difference_mw_plus ( fluid , mw_source , method , start , & difference , characterization ) end do end select if ( fix_C . and . C > 14 . or . C < 12 ) then if ( C > 14 ) C = 14 if ( C < 12 ) C = 12 Start = . true . plus_mw = fluid % plus_mw call difference_mw_plus ( fluid , mw_source , \"plus_mw\" , start , & difference_old , characterization ) plus_mw_old = plus_mw plus_mw = 0.9 * plus_mw Start = . false . call difference_mw_plus ( fluid , mw_source , \"plus_mw\" , start , & difference , characterization ) do while ( abs ( difference ) > 0.00001 ) aux = plus_mw plus_mw = plus_mw - difference * ( plus_mw - plus_mw_old ) / ( difference - difference_old ) plus_mw_old = aux difference_old = difference call difference_mw_plus ( fluid , mw_source , \"plus_mw\" , start , & difference , characterization ) end do end if end associate end subroutine get_c_or_m_plus subroutine density_funtion ( fluid , mw_source , characterization ) !! this subroutine ... implicit none type ( FluidData ) :: fluid type ( FluidDataOut ) :: characterization character ( len =* ), intent ( in ) :: mw_source !real(pr), allocatable :: volume_6plus_cal(:) real ( pr ) :: volume_6plus_exp real ( pr ) :: a_d_old , aux real ( pr ) :: difference , difference_old volume_6plus_exp = sum (( fluid % product_z_mw_scn ) / ( fluid % scn_density )) + & ( fluid % product_z_mw_plus / fluid % plus_density ) associate ( & a_d => characterization % a_d , & b_d => characterization % b_d , & volume_6plus_cal => characterization % volume_6plus_cal & ) ! Now find constants for the Density function a_d = - 0.50_pr ! initial guess b_d = 0.685_pr - a_d * exp ( - 0.60_pr ) call calculate_volume_6plus ( fluid , mw_source , characterization ) difference_old = volume_6plus_cal - volume_6plus_exp a_d_old = a_d a_d = - 0.49_pr b_d = 0.685_pr - a_d * exp ( - 0.60_pr ) call calculate_volume_6plus ( fluid , mw_source , characterization ) difference = volume_6plus_cal - volume_6plus_exp do while ( abs ( difference ) > 0.001_pr ) aux = a_d a_d = a_d - difference * ( a_d - a_d_old ) / ( difference - difference_old ) b_d = 0.685_pr - a_d * exp ( - 0.60_pr ) a_d_old = aux difference_old = difference call calculate_volume_6plus ( fluid , mw_source , characterization ) difference = volume_6plus_cal - volume_6plus_exp end do end associate end subroutine density_funtion subroutine calculate_volume_6plus ( fluid , mw_source , characterization ) !! this subroutine ... implicit none type ( FluidData ), intent ( in ) :: fluid type ( FluidDataOut ), intent ( inout ) :: characterization character ( len =* ), intent ( in ) :: mw_source real ( pr ) :: volume_6plus_cal real ( pr ), allocatable :: plus_density_cal (:), scn_density_cal (:), plus6_density (:) !allocate(density_plus_cal(0), density_scn_cal(0), plus6_density(0)) associate (& a_d => characterization % a_d , & b_d => characterization % b_d , & cn_plus => characterization % carbon_number_plus , & z_m_plus_i => characterization % product_z_mw_plus_i , & scn_z_i => characterization % scn_z , & scn_mw_i => characterization % scn_mw & ) scn_density_cal = (( a_d ) * ( exp ( - ( real ( fluid % scn , pr )) / 1 0._pr ))) + b_d plus_density_cal = (( a_d ) * ( exp ( - ( real ( cn_plus , pr ) ) / 1 0._pr ))) + b_d select case ( mw_source ) case ( \"experimental\" ) volume_6plus_cal = sum (( scn_z_i * scn_mw_i ) / ( fluid % scn_density )) + & sum ( z_m_plus_i / plus_density_cal ) plus6_density = [ fluid % scn_density , plus_density_cal ] case ( \"calculated\" ) volume_6plus_cal = sum (( scn_z_i * scn_mw_i ) / ( scn_density_cal )) + & sum ( z_m_plus_i / plus_density_cal ) plus6_density = [ scn_density_cal , plus_density_cal ] end select characterization % volume_6plus_cal = volume_6plus_cal characterization % plus6_density = plus6_density end associate end subroutine calculate_volume_6plus subroutine lump ( fluid , characterization ) !! This sobroutine ... implicit none type ( FluidData ), intent ( in ) :: fluid type ( FluidDataOut ), intent ( inout ) :: characterization integer :: last_C ! CN of last single cut: typically 19 integer :: i_last ! Number of elements in the distribution of CN+ integer :: last ! Total elements starting after defined components. integer :: scn_nc_input !! inicial number of single cuts being considered in the oil from data input integer :: scn_nc_new !! new number of single cuts being considered in the oil defined as from scn_nc_ps variable. real ( pr ) :: plus_w_new real ( pr ), allocatable :: z_m_plus_i (:) real ( pr ), allocatable :: plus_z_i (:) real ( pr ), allocatable :: var_aux_1 (:) real ( pr ), allocatable :: var_aux_2 (:) integer :: i , prev_i integer , dimension ( 15 ) :: j_ps integer :: i_ps ! auxiliary variables real ( pr ) :: rec_zm , remain_plus_zm , sum_z , sum_zm , sum_volume_ps ! auxiliary variables real ( pr ), allocatable :: plus_z_ps (:) real ( pr ), allocatable :: plus_mw_ps (:) integer :: numbers_ps real ( pr ), allocatable :: density_ps (:) real ( pr ), allocatable :: w_ps (:) real ( pr ) :: sum_zm_last_ps associate (& plus_zm => characterization % plus_zm , & scn_zm => characterization % scn_zm , & plus_z => characterization % plus_z , & scn_z => characterization % scn_z , & plus_w => fluid % plus_w , & w => fluid % w , & plus_mw => characterization % plus_mw , & carbon_number_plus => characterization % carbon_number_plus , & C => characterization % C & ) last_C = fluid % scn ( fluid % scn_nc ) !19 i_last = characterization % nc_plus !124 last = fluid % scn_nc + i_last !138 allocate ( z_m_plus_i ( 0 )) allocate ( plus_z_i ( 0 )) allocate ( var_aux_1 ( 0 )) allocate ( var_aux_2 ( 0 )) allocate ( plus_z_ps ( 0 )) allocate ( plus_mw_ps ( 0 )) allocate ( density_ps ( 0 )) allocate ( w_ps ( 0 )) scn_nc_input = fluid % scn_nc scn_nc_new = fluid % scn_nc_ps - 6 ! scn_nc_ps : CN from which all SCN fractions will be lumped ! into the specified number of pseudos characterization % plus_w = plus_w z_m_plus_i = characterization % product_z_mw_plus_i plus_z_i = characterization % plus_z_i if ( scn_nc_new < scn_nc_input ) then ! Plus Fraction needs to be extended to include lower CN's plus_zm = plus_zm + sum ( scn_zm ( scn_nc_new + 1 : scn_nc_input )) plus_z = plus_z + sum ( scn_z ( scn_nc_new + 1 : scn_nc_input )) !extended zp plus_w_new = plus_w + sum ( w ( fluid % def_comp_nc + scn_nc_new + 1 & : fluid % def_comp_nc + scn_nc_input )) !! use new variable for plus_w because type fluidata can't be modified. plus_mw = plus_zm / plus_z z_m_plus_i = scn_zm ( scn_nc_new + 1 : scn_nc_input ) z_m_plus_i = [ z_m_plus_i , characterization % product_z_mw_plus_i ] plus_z_i = scn_z ( scn_nc_new + 1 : scn_nc_input ) plus_z_i = [ plus_z_i , characterization % plus_z_i ] i_last = i_last + scn_nc_input - scn_nc_new last_C = last_C - scn_nc_input + scn_nc_new characterization % plus_w = plus_w_new characterization % product_z_mw_plus_i = z_m_plus_i characterization % plus_z_i = plus_z_i end if numbers_ps = fluid % numbers_ps j_ps = 0 ! Lumping into Nps pseudos rec_zm = plus_zm / numbers_ps ! Recommended value for the product z*M (proportional to weight) !for each pseudo according to pedersen remain_plus_zm = plus_zm i_ps = 1._pr sum_z = 0.0_pr sum_zm = 0.0_pr sum_volume_ps = 0.0_pr i = 0.0_pr do while ( i_ps < numbers_ps ) i = i + 1 j_ps ( i_ps ) = j_ps ( i_ps ) + 1 sum_z = sum_z + plus_z_i ( i ) sum_zm = sum_zm + z_m_plus_i ( i ) sum_volume_ps = sum_volume_ps + z_m_plus_i ( i ) / & characterization % plus6_density ( scn_nc_new + i ) if ( z_m_plus_i ( i + 1 ) > 2 * ( rec_zm - sum_zm )) then ! when adding one more would go too far plus_z_ps = [ plus_z_ps , sum_z ] plus_mw_ps = [ plus_mw_ps , sum_zm / sum_z ] w_ps = [ w_ps , ( characterization % plus_w * ( sum_zm / plus_zm ))] remain_plus_zm = remain_plus_zm - sum_zm if ( remain_plus_zm < rec_zm ) numbers_ps = i_ps + 1 carbon_number_plus ( scn_nc_new + i_ps ) = 6 + (( plus_mw_ps ( i_ps ) - 84 ) / C ) density_ps = [ density_ps , ( sum_zm / sum_volume_ps )] i_ps = i_ps + 1 sum_z = 0._pr sum_zm = 0._pr sum_volume_ps = 0._pr end if end do plus_z_ps = [ plus_z_ps , sum ( plus_z_i ( i + 1 : i_last ))] ! at this point, Nps is the order for the last NON-Asphaltenic pseudo comp. ! (e.g. 4 if 5 is for Asphaltenes) plus_mw_ps = [ plus_mw_ps , sum ( z_m_plus_i ( i + 1 : i_last )) / plus_z_ps ( numbers_ps )] ! (zMp - sum(zMpi(1:i))) / zps(Nps) w_ps = [ w_ps , characterization % plus_w * (( plus_z_ps ( numbers_ps )) * & ( plus_mw_ps ( numbers_ps )) / ( plus_zm ))] carbon_number_plus ( scn_nc_new + numbers_ps ) = 6 + & (( plus_mw_ps ( numbers_ps ) - 84 ) / C ) sum_zm_last_ps = ( sum ( z_m_plus_i ( i + 1 : i_last ))) density_ps = [ density_ps , (( sum_zm_last_ps ) / ( sum ( z_m_plus_i ( i + 1 : i_last )) & / ( characterization % plus6_density ( scn_nc_new + i + 1 : i_last ))))] j_ps ( numbers_ps ) = i_last - sum ( j_ps ( 1 : numbers_ps - 1 )) do i = 1 , numbers_ps print * , 'ps' , i , plus_z_ps ( i ), plus_mw_ps ( i ), density_ps ( i ), j_ps ( i ), carbon_number_plus ( scn_nc_new + i ) end do end associate !characterization%product_z_mw_plus_i = z_m_plus_i !characterization%plus_z_i = plus_z_i characterization % last_C = last_C characterization % i_last = i_last !! esto es lo que haria en el write, luego eliminar este comentario. !prev_i = fluid%scn(1)-1 !do i = 1, scn_nc_new !   print*,  prev_i + i ,  characterization%scn_z(i) , characterization%scn_mw(i) !end do end subroutine lump subroutine get_critical_constants ( fluid , characterization ) !! this subroutine .... type ( FluidData ), intent ( in ) :: fluid type ( FluidDataOut ), intent ( inout ) :: characterization !implicit none end subroutine get_critical_constants type ( FluidDataOut ) function characterize ( file , mw_source , method , fix_C ) & result ( characterization ) type ( FluidData ) :: fluid character ( len =* ), intent ( in ) :: file !! file name character ( len =* ), intent ( in ), optional :: method !! plus_mw or global_mw character ( len =* ), intent ( in ) :: mw_source logical , intent ( in ), optional :: fix_C fluid = data_from_file ( file ) allocate ( characterization % scn_z ( fluid % scn_nc )) allocate ( characterization % log_scn_z ( fluid % scn_nc )) allocate ( characterization % scn_mw ( fluid % scn_nc )) allocate ( characterization % carbon_number_plus ( 0 )) allocate ( characterization % plus_z_i ( 0 )) allocate ( characterization % product_z_mw_plus_i ( 0 )) allocate ( characterization % scn_zm ( fluid % scn_nc )) allocate ( characterization % scn_i ( 0 )) allocate ( characterization % plus6_density ( 0 )) call get_c_or_m_plus ( fluid = fluid , mw_source = mw_source , method = method , fix_C = fix_C , characterization = characterization ) call density_funtion ( fluid = fluid , mw_source = mw_source , characterization = characterization ) call lump ( fluid = fluid , characterization = characterization ) end function characterize end module routines","tags":"","loc":"sourcefile/routines.f90.html"},{"title":"module.f90 – Forcha","text":"This file depends on sourcefile~~module.f90~~EfferentGraph sourcefile~module.f90 module.f90 sourcefile~constans.f90 constans.f90 sourcefile~module.f90->sourcefile~constans.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module data use constants , only : pr !use types, only: FluidData implicit none integer :: nv , nv1 , nNcut , nNdef real ( pr ) :: Zplus contains subroutine data_in ( Nfluid , Oil , Ncut , Ndef , DefComp , zdef , rMdef , rCN , zcomp , rMW ,& Den , Plus , rMWplus , DenPlus , Nps , wat , watPlus , zM , zMp , Z6p , sumV , w , rn ) implicit none integer , parameter :: maxD = 15 , imax = 48 integer :: i , j !, nv1 integer :: file_unit_1 , file_unit_2 , file_unit_3 , Nfluid , Ncut , Ndef , Nps integer , dimension ( 330 ) :: rCN real ( pr ), dimension ( maxD ) :: zdef , rMdef real ( pr ), dimension ( imax ) :: zcomp , rMW , Den , wat , zM , zMdef , w , rn , MWt real ( pr ) :: rMWplus , DenPlus , watPlus , zMp , Z6p , sumV , zMtotal character ( len = 30 ) :: infile , outfile character ( len = 7 ) :: Oil , Plus character ( len = 4 ) :: DefComp ( maxD ) write ( * , * ) 'ARE MOLECULAR WEIGTHS FROM DATAIN EXPERIMENTAL?' write ( * , * ) '1: YES   2: NO' read ( * , * ) nv write ( * , * ) 'ENTER THE VERSION NUMBER' write ( * , * ) '1: C.M   2: CMplus' read ( * , * ) nv1 !nv2 = nv1 ! open input file write ( * , * ) 'ENTER INFILE' read ( * , * ) infile write ( * , * ) \"READING INFILE: \" // infile open ( newunit = file_unit_1 , file = infile ) write ( * , * ) 'ENTER OUTFILE' read ( * , * ) outfile open ( newunit = file_unit_2 , file = outfile ) open ( newunit = file_unit_3 , file = 'TfPsatIn.txt' ) ! read input file:read number fluid, single carbon number for each fluid. read ( file_unit_1 , * ) Nfluid do j = 1 , Nfluid read ( file_unit_1 , * ) Oil read ( file_unit_1 , * ) Ncut , Ndef end do nNcut = Ncut nNdef = Ndef ! read defined compounds with  molar fraction and M by fluid j and compound i. do i = 1 , Ndef read ( file_unit_1 , * ) DefComp ( i ), zdef ( i ), rMdef ( i ) end do ! read carbon number and molar fraction of fluid j and comp. i do i = 1 , Ncut read ( file_unit_1 , * ) rCN ( i ), zcomp ( i ), rMW ( i ), Den ( i ) end do read ( file_unit_1 , * ) Plus , zPlus , rMWplus , DenPlus ! plus fraction properties read ( file_unit_1 , * ) Nps !number of pseudos for the C20+ fraction read ( file_unit_1 , * ) wat ( 1 : Ndef + Ncut ), watPlus ! atmospheric oil weight fractions !zpl  =  zPlus ! added by oscar ! There get Zi*Mi and volume from cut to plus fraction zMdef ( 1 : Ndef ) = zdef ( 1 : Ndef ) * rMdef ( 1 : Ndef ) zM ( 1 : Ncut ) = zcomp ( 1 : Ncut ) * rMW ( 1 : Ncut ) zMp = zPlus * rMWplus zMtotal = sum ( zMdef ( 1 : Ndef )) + sum ( zM ( 1 : Ncut )) + zMp w ( 1 : Ndef ) = zMdef ( 1 : Ndef ) / zMtotal w ( Ndef + 1 : Ndef + Ncut ) = zM ( 1 : Ncut ) / zMtotal w ( Ndef + Ncut + 1 ) = zMp / zMtotal rn ( 1 : Ndef ) = zdef ( 1 : Ndef ) / zMtotal Z6p = sum ( zcomp ( 1 : Ncut )) + zPlus sumV = sum ( zM ( 1 : Ncut ) / Den ( 1 : Ncut )) + zMp / DenPlus !agregado para calcular el peso molecular global !MWt(1:Ndef) = rMdef(1:Ndef) !MWt(Ndef+1:Ndef+Ncut) = rMW(1:Ncut) !do i= 1, Ndef+Ncut !    print*, MWt(i) !end do !print*, Zplus end subroutine data_in end module data module routines_pre use constants , only : pr !use dtypes, only: FluidDataOut use data contains subroutine Linear_Regression ( x , y , a , b , r2 ) !! This subroutine computes the regression line for a data set of x, y variables. implicit none integer :: i integer :: n !! total number of data set. real ( pr ), allocatable , intent ( in ) :: x (:) !! x: input array of length n which contains the set of independent variable real ( pr ), allocatable , intent ( in ) :: y (:) !! y: input array of length n which contains the set of dependent variable real ( pr ) :: t1 , t2 , t3 , t4 , aux1 , aux2 , aux3 , aux4 , aux5 ! internal variables real ( pr ), intent ( out ) :: a !! a: output real variable. Slope of the regression line real ( pr ), intent ( out ) :: b !! b: output real variable. Intercept of the regression line real ( pr ), intent ( out ) :: r2 !! r2: output real variable. Square correlation coefficient n = size ( x ) !Calculation of a y b --> y=a*x+b t1 = 0. ; t2 = 0. ; t3 = 0. ; t4 = 0. ; do i = 1 , n t1 = t1 + x ( i ) * y ( i ) t2 = t2 + x ( i ) t3 = t3 + y ( i ) t4 = t4 + x ( i ) ** 2 end do a = ( n * t1 - t2 * t3 ) / ( n * t4 - t2 ** 2 ) b = ( t3 - a * t2 ) / n !coefficient calculation of correlations r2 aux1 = 0. ; aux2 = 0. ; aux3 = 0. ; aux4 = 0. ; aux5 = 0. ; do i = 1 , n aux1 = aux1 + x ( i ) * y ( i ) aux2 = aux2 + x ( i ) aux3 = aux3 + y ( i ) aux4 = aux4 + x ( i ) ** 2 aux5 = aux5 + y ( i ) ** 2 end do r2 = ( aux1 - aux2 * aux3 / n ) ** 2 / (( aux4 - aux2 ** 2 / n ) * ( aux5 - aux3 ** 2 / n )) end subroutine Linear_Regression subroutine Best_Linear_Regression ( scn_nc , scn , scn_z , plus_z , a , b , r2 , ninit ) !! This subroutine calculates the best regression line for an oil. implicit none integer , intent ( in ) :: scn_nc !! integer input variable set to the total number of single cuts being considered in the oil integer , allocatable , intent ( in ) :: scn (:) !! set of singles cuts being considered in the oil integer :: i , j , k , kold , nbest , xaux , cbmax ! internal variables real , allocatable , intent ( in ) :: scn_z (:) !! set of corresponding mole fractions of scn cuts real ( pr ), intent ( in ) :: plus_z real ( pr ), intent ( out ) :: a !! output real variable. Slope of the best regression line. real ( pr ), intent ( out ) :: b !! output real variable. Intercept of the best regression line. real ( pr ), intent ( out ) :: r2 !! output real variable. Square correlation coefficient. integer , intent ( out ) :: ninit !! minimum carbon number obtained from the best linear regression real ( pr ), allocatable :: xBR (:), yBR (:) real ( pr ) :: r2old , r2best , aold , bold , abest , bbest , zsum , zaux allocate ( scn ( scn_nc )) allocate ( scn_z ( scn_nc )) allocate ( xBR ( scn_nc )) allocate ( yBR ( scn_nc )) k = 5 r2 = 0.0001d0 r2old = 0.00001d0 r2best = 0.0001d0 do while ( r2 . gt . r2old . or . r2old . lt . 0.9 ) kold = k r2old = r2 aold = a bold = b if ( r2 . gt . r2best ) then r2best = r2 abest = a bbest = b nbest = scn ( scn_nc - k + 2 ) end if if ( k . gt . scn_nc ) then if ( r2 . gt . r2best ) then ninit = scn ( scn_nc - k + 2 ) go to 22 else r2 = r2best a = abest b = bbest ninit = nbest go to 22 end if end if j = 1 xBR = 0. yBR = 0. do i = scn_nc - k + 1 , scn_nc xBR ( j ) = scn ( i ) yBR ( j ) = scn_z ( i ) j = j + 1 end do call LinearRegression ( xBR (: k ), yBR (: k ), a , b , r2 ) k = k + 1 end do r2 = r2old a = aold b = bold ninit = scn ( scn_nc - kold + 2 ) 22 continue zsum = 0 d0 xaux = scn ( scn_nc ) do while ( zsum . lt . plus_z . and . xaux < 300 ) xaux = xaux + 1 zaux = exp ( a * xaux + b ) zsum = zsum + zaux end do cbmax = xaux print * , a , b , cbmax , r2 , Ninit end subroutine Best_Linear_Regression subroutine get_C ( start , C , Ncut , rCN , zM , zMp , Z6p , a , b , rMp , maxC , z , zpi , zMpi , Ndef , zp , w , rn , rMWplus , zcomp , zdef ) implicit none integer , parameter :: imax = 48 , maxD = 15 logical :: start real ( pr ) :: C , Z6p , zMp , a , b , rMp , rMWplus real ( pr ) :: aux , dold , dif , Cold , zp real ( pr ), dimension ( imax ) :: zM ! inputs coming from main program integer , dimension ( imax ) :: rCN ! inputs coming from main program real ( pr ), dimension ( imax ) :: z , rM , w , rn , zcomp integer :: Ncut , maxC , Ndef real ( pr ), dimension ( 300 ) :: zpi , zMpi real ( pr ), dimension ( maxD ) :: zdef !write(*,*) 'ENTER THE VERSION NUMBER' !write(*,*) '1: CMOD   2: CMM' !read(*,*) nv if ( nv1 == 1 ) then ! Find the C value for molecular weights line C = 1 3.0 ! initial guess Start = . true . rMp = rMWplus call difMpfromC ( start , C , Ncut , rCN , zM , zMp , Z6p , dold , a , b , rMp , maxC , z , zpi , zMpi , zcomp , zdef , zp ) Cold = C C = min ( 1 2.8 , C - 0.07 ) Start = . false . call difMpfromC ( start , C , Ncut , rCN , zM , zMp , Z6p , dif , a , b , rMp , maxC , z , zpi , zMpi , zcomp , zdef , zp ) do while ( abs ( dif ) > 0.1 ) aux = C C = C - dif * ( C - Cold ) / ( dif - dold ) Cold = aux dold = dif call difMpfromC ( start , C , Ncut , rCN , zM , zMp , Z6p , dif , a , b , rMp , maxC , z , zpi , zMpi , zcomp , zdef , zp ) end do !print*, C,maxC, rMp else ! Find the C value for molecular weights line C = 1 4.0 ! initial guess  and maximum C allowed Start = . true . rMp = rMWplus call difMpfromCfull ( Start , C , Ndef , Ncut , rCN , dold , a , b , rM , rMp , maxC , z , zp , zpi , zMpi , w , rn , zcomp , zdef ) Cold = C C = 1 3.5 !min(12.8,C-0.07) Start = . false . call difMpfromCfull ( Start , C , Ndef , Ncut , rCN , dif , a , b , rM , rMp , maxC , z , zp , zpi , zMpi , w , rn , zcomp , zdef ) do while ( abs ( dif ) > 0.1 ) aux = C C = C - dif * ( C - Cold ) / ( dif - dold ) Cold = aux dold = dif call difMpfromCfull ( Start , C , Ndef , Ncut , rCN , dif , a , b , rM , rMp , maxC , z , zp , zpi , zMpi , w , rn , zcomp , zdef ) end do !print*, C, maxC, rMp, zp end if end subroutine get_C subroutine difMpfromC ( start , C , Ncut , rCN , zM , zMp , Z6p , dif , a , b , rMp , maxC , z , zpi , zMpi , zcomp , zdef , zp ) use data implicit none integer , parameter :: imax = 48 , maxD = 15 logical :: start real ( pr ) :: C , Z6p , zMp , dif , a , b , rMp , zp , aBE , bBE , r2 , alim , blim , half real ( pr ) :: a60 , b60 , sumz , rMpcalc real ( pr ), dimension ( imax ) :: zM ! inputs coming from main program integer , dimension ( imax ) :: rCN , x ! inputs coming from main program real ( pr ), dimension ( imax ) :: ylog , rM , z , zcomp integer :: i , Ncut , maxC , i0 , CmaxL , C60max real ( pr ), dimension ( 300 ) :: zpi , zMpi real ( pr ), dimension ( maxD ) :: zdef ! 1       i0 = rCN(Ncut) i = 300 sumz = - 1 do while ( i == 30 0. and . sumz < Zp ) i0 = rCN ( Ncut ) if ( nv == 1 ) then !introduce 'if' to choise where experimental data from x = rCN ylog = log ( zcomp ) zp = 1 - sum ( zdef ( 1 : nNdef )) - sum ( zcomp ( 1 : nNcut )) !zp = zpl end if if ( nv == 2 ) then rM ( 1 : Ncut ) = 84 + C * ( rCN ( 1 : Ncut ) - 6 ) z ( 1 : Ncut ) = zM ( 1 : Ncut ) / rM ( 1 : Ncut ) Zp = Z6p - sum ( z ( 1 : Ncut )) ! new molar fraction for residual cut, based on C rMp = zMp / Zp x = rCN ylog = log ( z ) end if print * , zp call BestLinearRegression ( Ncut , x , ylog , Zp , aBE , bBE , r2 ) call LimitLine ( Ncut , rCN , Zp , aBE , bBE , half , alim , blim , CmaxL ) call LineC60max ( Ncut , Zp , rCN , aBE , bBE , half , a60 , b60 , C60max ) if ( aBE < alim ) then ! added by oscar 05/12/2023.se elimina por que se agregan las restriccones para C>12 y C<12. a = alim b = blim else !call LineC60max (Ncut,Zp,rCN,aBE,bBE,half,a60,b60,C60max) if ( aBE > a60 ) then a = a60 b = b60 else a = aBE b = bBE end if end if sumz = 0.0d0 i = 0 do while ( sumz < Zp . and . i < 300 ) i = i + 1 zpi ( i ) = exp ( a * ( i + i0 ) + b ) sumz = sumz + zpi ( i ) zMpi ( i ) = zpi ( i ) * ( 84 + C * ( i + i0 - 6 )) end do if ( start ) C = C - 0.07 ! modificado por fede if (. not . start ) C = C - 0.01 end do !   Adjustment to Zp (z20+) zpi ( i ) = zpi ( i ) - ( sumz - Zp ) zMpi ( i ) = zpi ( i ) * ( 84 + C * ( i + i0 - 6 )) ! =============================== rMpcalc = sum ( zMpi ( 1 : i )) / Zp dif = rMpcalc - rMp maxC = i + i0 end subroutine difMpfromC subroutine difMpfromCfull ( Start , C , Ndef , Ncut , rCN , dif , a , b , rM , rMp , maxC , z , zp , zpi , zMpi , w , rn , zcomp , zdef ) !use MassFracAndMoles, only: w,rn use data implicit none integer , parameter :: imax = 48 , maxD = 15 logical :: start real ( pr ) :: C , dif , a , b , rMp , zp , aBE , bBE , r2 , alim , blim , half real ( pr ) :: a60 , b60 , sumz , rMpcalc , rntot , aold integer , dimension ( imax ) :: rCN , x ! inputs coming from main program real ( pr ), dimension ( imax ) :: ylog , rM , z , w , rn , zcomp , ztotal integer :: i , Ndef , Ncut , maxC , i0 , CmaxL , C60max real ( pr ), dimension ( 300 ) :: zpi , zMpi real ( pr ), dimension ( maxD ) :: zdef 1 i0 = rCN ( Ncut ) if ( nv == 1 ) then !introduce 'if' to choise where experimental data from x = rCN ylog = log ( zcomp ) zp = 1 - sum ( zdef ( 1 : nNdef )) - sum ( zcomp ( 1 : nNcut )) !zp = zpl end if if ( nv == 2 ) then rM ( 1 : Ncut ) = 84 + C * ( rCN ( 1 : Ncut ) - 6 ) rn ( Ndef + 1 : Ndef + Ncut ) = w ( Ndef + 1 : Ndef + Ncut ) / rM ( 1 : Ncut ) rn ( Ndef + Ncut + 1 ) = w ( Ndef + Ncut + 1 ) / rMp rntot = sum ( rn ( 1 : Ndef + Ncut + 1 )) ztotal ( 1 : Ndef + Ncut ) = rn ( 1 : Ndef + Ncut ) / rntot z ( 1 : Ncut ) = rn ( Ndef + 1 : Ndef + Ncut ) / rntot Zp = rn ( Ndef + Ncut + 1 ) / rntot x = rCN ylog = log ( z ) end if !print*, zp !print*, z call BestLinearRegression ( Ncut , x , ylog , Zp , aBE , bBE , r2 ) call LimitLine ( Ncut , rCN , Zp , aBE , bBE , half , alim , blim , CmaxL ) call LineC60max ( Ncut , Zp , rCN , aBE , bBE , half , a60 , b60 , C60max ) if ( aBE < alim ) then !, para C se excede el valor de 14 en la mayoria de los casos. a = alim b = blim else !call LineC60max (Ncut,Zp,rCN,aBE,bBE,half,a60,b60,C60max) if ( aBE > a60 ) then a = a60 b = b60 else a = aBE b = bBE end if end if sumz = 0.0d0 i = 0 do while ( sumz < Zp . and . i < 300 ) i = i + 1 zpi ( i ) = exp ( a * ( i + i0 ) + b ) sumz = sumz + zpi ( i ) zMpi ( i ) = zpi ( i ) * ( 84 + C * ( i + i0 - 6 )) end do !agregar condicion cuando C = 14 o C = 12 no olvidar consultar con martin if ( i == 30 0. and . sumz < Zp ) then if ( start ) C = C - 0.07 if (. not . start ) C = C - 0.01 go to 1 end if !    do while (i<40.and.a>alim) eliminado por oscar 20/03/2024 !        aold = a !        a = max(1.0001*a, alim) !        b = b - (a-aold)*19.51 !        sumz = 0.0d0 !        i = 0 !        do while (sumz<Zp.and.i<300) !            i = i+1 !            zpi(i) = exp(a*(i+i0)+b) !            sumz = sumz + zpi(i) !            zMpi(i) = zpi(i)*(84+C*(i+i0-6)) !        end do !    end do !   Adjustment to Zp (z20+) zpi ( i ) = zpi ( i ) - ( sumz - Zp ) zMpi ( i ) = zpi ( i ) * ( 84 + C * ( i + i0 - 6 )) ! =============================== rMpcalc = sum ( zMpi ( 1 : i )) / Zp dif = rMpcalc - rMp maxC = i + i0 end subroutine difMpfromCfull subroutine LimitLine ( Ncut , rCN , Zp , aBE , bBE , half , alim , blim , Cmax ) !================================================================================================================ !This subroutine obtains the limit line constants for an oil. !Ncut: integer input number of single cuts being considered in the oil. !rCN: input array which contains the set of carbon numbers. !Zp: input mole fractions of the residual fraction. !aBE & bBE: input constants from the Best Extrapolation !alim: output real variable. Slope of the limit line. !blim: output real variable. Intercept of the limit line. !Cmax: output CN at which Zp is reached, as the summation of single z(i) from the limit distribution. !================================================================================================================ implicit none integer , parameter :: imax = 48 integer :: Ncut , xaux , Cmax integer , dimension ( imax ) :: rCN real ( pr ) :: Zp , aBE , bBE , half , alim , blim , zlim , crossCN , zcross , zaux !A and B limit calculation. zlim = 0.d0 half = 0.506d0 do while ( zlim . lt . Zp ) half = half + 0.002d0 crossCN = rCN ( Ncut ) + half ! typically 19.508 in first try zcross = exp ( aBE * crossCN + bBE ) alim = - zcross / Zp blim = log ( zcross ) - alim * crossCN xaux = rCN ( Ncut ) zlim = 0.d0 do while ( zlim . lt . Zp . and . xaux < 300 ) xaux = xaux + 1 zaux = exp ( alim * xaux + blim ) zlim = zlim + zaux end do continue end do Cmax = xaux !print*, alim,blim,Cmax end subroutine LimitLine subroutine LineC60max ( Ncut , Zp , rCN , aBE , bBE , half , a60 , b60 , C60max ) !================================================================================================================ !This subroutine obtains the Cmax60 line constants for an oil. !Ncut: integer input number of single cuts being considered in the oil. !rCN: input array which contains the set of carbon numbers. !Zp: input mole fractions of the residual fraction. !aBE & bBE: input constants from the Best Extrapolation !a60: output real variable. Slope of the limit line. !b60: output real variable. Intercept of the limit line. !C60max: output CN at which Zp is reached, as the summation of single z(i) from the Cmax60 distribution. !================================================================================================================ implicit none integer , parameter :: imax = 48 integer :: Ncut , xaux , C60max integer , dimension ( imax ) :: rCN real ( pr ) :: Zp , aBE , bBE , half , a60 , b60 , zsum , crossCN , zcross , zaux , Ftol , atol , range real ( pr ) :: a_old , Zp60 , F , dFdA crossCN = rCN ( Ncut ) + half ! typically 19.51 zcross = exp ( aBE * crossCN + bBE ) Ftol = 1 d0 atol = 1 d0 a60 = aBE range = 6 0.5d0 - crossCN do while ( atol . gt . 1e-6 . or . Ftol . gt . 1e-6 ) a_old = a60 Zp60 = ( exp ( a60 * range + log ( zcross )) - zcross ) / a60 F = Zp - Zp60 !dFdA = - (60.5*(a60*Zp60+zcross)-Zp60) / a60 dFdA = - ( range * ( a60 * Zp60 + zcross ) - Zp60 ) / a60 a60 = a_old - F / dFdA atol = abs ( a_old - a60 ) Ftol = abs ( F ) end do b60 = log ( zcross ) - a60 * crossCN zsum = 0 d0 xaux = rCN ( Ncut ) do while ( zsum . lt . Zp ) xaux = xaux + 1 zaux = exp ( a60 * xaux + b60 ) zsum = zsum + zaux end do C60max = xaux !print*, a60,b60,C60max end subroutine LineC60max subroutine GetNewMpfromC ( start , C , Ncut , rCN , zM , zMp , Z6p , a , b , rMp , maxC , z , zpi , zMpi , Ndef , zp , w , rn , rMWplus , zcomp , zdef , rMW , rMdef , Mglobal ) !! this subroutines for a C value returns the correponding  new M20+ value implicit none integer , parameter :: imax = 48 , maxD = 15 logical :: start real ( pr ) :: C , Z6p , zMp , a , b , rMp , rMWplus , Mglobal real ( pr ) :: aux , dold , dif , rMpold , zp real ( pr ), dimension ( imax ) :: zM ! inputs coming from main program integer , dimension ( imax ) :: rCN ! inputs coming from main program real ( pr ), dimension ( imax ) :: z , rM , w , rn , zcomp , rMW integer :: Ncut , maxC , Ndef real ( pr ), dimension ( 300 ) :: zpi , zMpi real ( pr ), dimension ( maxD ) :: zdef , rMdef if ( nv1 == 1 ) then ! Find the new rMp for a fixed C constant !C = 14  ! fixed value call difMpfromC ( start , C , Ncut , rCN , zM , zMp , Z6p , dif , a , b , rMp , maxC , z , zpi , zMpi , zcomp , zdef , zp ) !print*, C, maxC, rMp else ! Find the new rMp for a fixed C constant !C = 14  ! fixed value Start = . true . rMp = rMWplus !inicial guess call difnewMp ( Start , C , Ndef , Ncut , rCN , dold , a , b , rM , rMp , maxC , z , zp , zpi , zMpi , w , rn , zcomp , zdef , rMW , rMdef , Mglobal ) rMpold = rMp rMp = 0.9 * rMp Start = . false . call difnewMp ( Start , C , Ndef , Ncut , rCN , dif , a , b , rM , rMp , maxC , z , zp , zpi , zMpi , w , rn , zcomp , zdef , rMW , rMdef , Mglobal ) do while ( abs ( dif ) > 0.00001 ) aux = rMp rMp = rMp - dif * ( rMp - rMpold ) / ( dif - dold ) rMpold = aux dold = dif call difnewMp ( Start , C , Ndef , Ncut , rCN , dif , a , b , rM , rMp , maxC , z , zp , zpi , zMpi , w , rn , zcomp , zdef , rMW , rMdef , Mglobal ) end do !print*, C, maxC, rMp !print*, zp , z6p !print*, z, zp end if end subroutine GetNewMpfromC subroutine difnewMp ( Start , C , Ndef , Ncut , rCN , dif , a , b , rM , rMp , maxC , z , zp , zpi , zMpi , w , rn , zcomp , zdef , rMW , rMdef , Mglobal ) !! this subroutines for a C value returns the correponding Mp value !use MassFracAndMoles, only: w,rn use data implicit none integer , parameter :: imax = 48 , maxD = 15 logical :: start real ( pr ) :: C , dif , a , b , rMp , zp , aBE , bBE , r2 , alim , blim , half real ( pr ) :: a60 , b60 , sumz , rMpcalc , rntot , aold , Mglobal integer , dimension ( imax ) :: rCN , x ! inputs coming from main program real ( pr ), dimension ( imax ) :: ylog , rM , z , w , rn , zcomp , ztotal , rMW , MWt integer :: i , Ndef , Ncut , maxC , i0 , CmaxL , C60max real ( pr ), dimension ( 300 ) :: zpi , zMpi , ZM_1 real ( pr ), dimension ( maxD ) :: zdef , rMdef 1 i0 = rCN ( Ncut ) if ( nv == 1 ) then !introduce 'if' to choise where experimental data from x = rCN rn ( Ndef + 1 : Ndef + Ncut ) = w ( Ndef + 1 : Ndef + Ncut ) / rMW ( 1 : Ncut ) rn ( Ndef + Ncut + 1 ) = w ( Ndef + Ncut + 1 ) / rMp rntot = sum ( rn ( 1 : Ndef + Ncut + 1 )) ztotal ( 1 : Ndef + Ncut ) = rn ( 1 : Ndef + Ncut ) / rntot z ( 1 : Ncut ) = rn ( Ndef + 1 : Ndef + Ncut ) / rntot Zp = rn ( Ndef + Ncut + 1 ) / rntot !ylog = log(zcomp) ylog = log ( z ) !calculo m global MWt ( 1 : Ndef ) = rMdef ( 1 : Ndef ) MWt ( Ndef + 1 : Ndef + Ncut ) = rMW ( 1 : Ncut ) ZM_1 ( 1 : Ndef + Ncut ) = ztotal ( 1 : Ndef + Ncut ) * MWt ( 1 : Ndef + Ncut ) !do i= 1, Ndef+Ncut !    print*, MWt(i) !end do end if if ( nv == 2 ) then rM ( 1 : Ncut ) = 84 + C * ( rCN ( 1 : Ncut ) - 6 ) rn ( Ndef + 1 : Ndef + Ncut ) = w ( Ndef + 1 : Ndef + Ncut ) / rM ( 1 : Ncut ) rn ( Ndef + Ncut + 1 ) = w ( Ndef + Ncut + 1 ) / rMp rntot = sum ( rn ( 1 : Ndef + Ncut + 1 )) ztotal ( 1 : Ndef + Ncut ) = rn ( 1 : Ndef + Ncut ) / rntot z ( 1 : Ncut ) = rn ( Ndef + 1 : Ndef + Ncut ) / rntot Zp = rn ( Ndef + Ncut + 1 ) / rntot x = rCN ylog = log ( z ) !calculo m global MWt ( 1 : Ndef ) = rMdef ( 1 : Ndef ) MWt ( Ndef + 1 : Ndef + Ncut ) = rM ( 1 : Ncut ) ZM_1 ( 1 : Ndef + Ncut ) = ztotal ( 1 : Ndef + Ncut ) * MWt ( 1 : Ndef + Ncut ) !do i= 1, Ndef+Ncut !    print*, MWt(i) !end do end if !print*, zp !print*, ztotal call BestLinearRegression ( Ncut , x , ylog , Zp , aBE , bBE , r2 ) call LimitLine ( Ncut , rCN , Zp , aBE , bBE , half , alim , blim , CmaxL ) call LineC60max ( Ncut , Zp , rCN , aBE , bBE , half , a60 , b60 , C60max ) if ( aBE < alim ) then !, para C se excede el valor de 14 en la mayoria de los casos. a = alim b = blim else !call LineC60max (Ncut,Zp,rCN,aBE,bBE,half,a60,b60,C60max) if ( aBE > a60 ) then a = a60 b = b60 else a = aBE b = bBE end if end if sumz = 0.0d0 i = 0 do while ( sumz < Zp . and . i < 300 ) i = i + 1 zpi ( i ) = exp ( a * ( i + i0 ) + b ) sumz = sumz + zpi ( i ) zMpi ( i ) = zpi ( i ) * ( 84 + C * ( i + i0 - 6 )) end do !agregar condicion cuando C = 14 o C = 12 no olvidar consultar con martin if ( i == 30 0. and . sumz < Zp ) then if ( start ) C = C - 0.07 if (. not . start ) C = C - 0.01 go to 1 end if do while ( i < 4 0. and . a > alim ) aold = a a = max ( 1.0001 * a , alim ) b = b - ( a - aold ) * 1 9.51 sumz = 0.0d0 i = 0 do while ( sumz < Zp . and . i < 300 ) i = i + 1 zpi ( i ) = exp ( a * ( i + i0 ) + b ) sumz = sumz + zpi ( i ) zMpi ( i ) = zpi ( i ) * ( 84 + C * ( i + i0 - 6 )) end do end do !   Adjustment to Zp (z20+) zpi ( i ) = zpi ( i ) - ( sumz - Zp ) zMpi ( i ) = zpi ( i ) * ( 84 + C * ( i + i0 - 6 )) ! =============================== rMpcalc = sum ( zMpi ( 1 : i )) / Zp dif = rMpcalc - rMp maxC = i + i0 ! calculo del peso molecular global Mglobal = sum ( ZM_1 ( 1 : Ndef + Ncut )) + sum ( zMpi ( 1 : i )) !rint*, Mglobal !print*, maxC !do i = 1, maxC-i0 !    print*, zpi(i) !end do !print*, '----------' !do i = 1, Ndef+Ncut !    print*, ztotal(i) !end do end subroutine difnewMp end module routines_pre","tags":"","loc":"sourcefile/module.f90.html"},{"title":"data_input.f90 – Forcha","text":"This file depends on sourcefile~~data_input.f90~~EfferentGraph sourcefile~data_input.f90 data_input.f90 sourcefile~constans.f90 constans.f90 sourcefile~data_input.f90->sourcefile~constans.f90 sourcefile~types.f90 types.f90 sourcefile~data_input.f90->sourcefile~types.f90 sourcefile~types.f90->sourcefile~constans.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~data_input.f90~~AfferentGraph sourcefile~data_input.f90 data_input.f90 sourcefile~prueba.f90 prueba.f90 sourcefile~prueba.f90->sourcefile~data_input.f90 sourcefile~routines.f90 routines.f90 sourcefile~routines.f90->sourcefile~data_input.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module data_from_input !! This module reads the fluid information from the corresponding input file. use dtypes , only : FluidData use constants , only : pr implicit none contains subroutine read_setup ( file , def_comp_nc , scn_nc , scn_nc_ps , numbers_ps ) !! Reads the setup data from input file character ( len =* ), intent ( in ) :: file !! file name integer , intent ( out ) :: def_comp_nc !! number of defined components being considered in the oil integer , intent ( out ) :: scn_nc !! number of single cuts being considered in the oil integer , intent ( out ) :: scn_nc_ps !! CN from which all SCN fractions will be lumped into the specified number of pseudos integer , intent ( out ) :: numbers_ps !! number of pseudos in which the scn fractions grouped integer :: funit namelist / nml_setup / def_comp_nc , scn_nc , scn_nc_ps , numbers_ps open ( newunit = funit , file = file ) read ( funit , nml = nml_setup ) close ( funit ) end subroutine read_setup subroutine read_components ( file , def_components , scn , scn_plus ) !! Reads the component names data from input file character ( len =* ), intent ( in ) :: file !! file name character ( len = 15 ), allocatable , intent ( out ) :: def_components (:) !! names of defined components integer , allocatable , intent ( out ) :: scn (:) !! names of scn fractions character ( len = 15 ), intent ( out ) :: scn_plus !! name of residual fraction integer :: def_comp_nc !! number of defined components being considered in the oil integer :: scn_nc !! number of single cuts being considered in the oil integer :: scn_nc_ps !! CN from which all SCN fractions will be lumped into the specified number of pseudos integer :: numbers_ps !! number of pseudos in which the scn fractions grouped integer :: funit namelist / nml_components / def_components , scn , scn_plus call read_setup ( file , def_comp_nc , scn_nc , scn_nc_ps , numbers_ps ) allocate ( def_components ( def_comp_nc )) allocate ( scn ( scn_nc )) open ( newunit = funit , file = file ) read ( funit , nml = nml_components ) close ( funit ) end subroutine read_components subroutine read_composition ( file , def_comp_z , scn_z , plus_z ) !! Reads the molar compositions of each component from input file character ( len =* ), intent ( in ) :: file !! file name real ( pr ), allocatable , intent ( out ) :: def_comp_z (:) !! set of corresponding mole fractions of defined components real ( pr ), allocatable , intent ( out ) :: scn_z (:) !! set of corresponding mole fractions of scn cuts real ( pr ), intent ( out ) :: plus_z !! composition of residual fraction from input file integer :: def_comp_nc !! number of defined components being considered in the oil integer :: scn_nc !! number of single cuts being considered in the oil integer :: scn_nc_ps !! CN from which all SCN fractions will be lumped into the specified number of pseudos integer :: numbers_ps !! number of pseudos in which the scn fractions grouped integer :: funit namelist / nml_composition / def_comp_z , scn_z , plus_z call read_setup ( file , def_comp_nc , scn_nc , scn_nc_ps , numbers_ps ) allocate ( def_comp_z ( def_comp_nc )) allocate ( scn_z ( scn_nc )) open ( newunit = funit , file = file ) read ( funit , nml = nml_composition ) close ( funit ) end subroutine read_composition subroutine read_molecular_weight ( file , def_comp_mw , scn_mw , plus_mw ) !! Reads the molecular weights of each component from the input file character ( len =* ), intent ( in ) :: file !! file name real ( pr ), allocatable , intent ( out ) :: def_comp_mw (:) !! set of corresponding molecular weights of defined components real ( pr ), allocatable , intent ( out ) :: scn_mw (:) !! set of corresponding molecular weights of scn cuts real ( pr ), intent ( out ) :: plus_mw !!  molecular weight of residual fraction integer :: def_comp_nc !! number of defined components being considered in the oil integer :: scn_nc !! number of single cuts being considered in the oil integer :: scn_nc_ps !! CN from which all SCN fractions will be lumped into the specified number of pseudos integer :: numbers_ps !! number of pseudos in which the scn fractions grouped integer :: funit namelist / nml_molecular_weight / def_comp_mw , scn_mw , plus_mw call read_setup ( file , def_comp_nc , scn_nc , scn_nc_ps , numbers_ps ) allocate ( def_comp_mw ( def_comp_nc )) allocate ( scn_mw ( scn_nc )) open ( newunit = funit , file = file ) read ( funit , nml = nml_molecular_weight ) close ( funit ) end subroutine read_molecular_weight subroutine mass_fractions ( file , w , product_z_mw_def_comp , product_z_mw_scn ,& sum_z_mw_i , product_z_mw_plus , def_comp_w , scn_w , plus_w ) !! This routine obtains the mass fractions of the fluid's compounds from !! the input file, additionally, it calculates the product (z*mw)_{i} character ( len =* ), intent ( in ) :: file !! file name real ( pr ), allocatable , intent ( out ) :: product_z_mw_def_comp (:) !! product between composition and molecular weight of defind components real ( pr ), allocatable , intent ( out ) :: product_z_mw_scn (:) !! product between composition and molecular weight of scn fractions real ( pr ), intent ( out ) :: sum_z_mw_i !! sum of the product between composition and molecular weight of the fluid's compounds real ( pr ), allocatable , intent ( out ) :: w (:) !! mass fractions of the fluid's compounds real ( pr ), intent ( out ) :: product_z_mw_plus !! product between composition and molecular weight of residual fraction integer :: def_comp_nc !! number of defined components being considered in the oil integer :: scn_nc !! number of single cuts being considered in the oil integer :: scn_nc_ps !! CN from which all SCN fractions will be lumped into the specified number of pseudos integer :: numbers_ps !! number of pseudos in which the scn fractions grouped integer :: funit real ( pr ), allocatable :: def_comp_z (:) !! set of corresponding mole fractions of defined components real ( pr ), allocatable :: scn_z (:) !! set of corresponding mole fractions of scn cuts real ( pr ) :: plus_z !! composition of residual fraction real ( pr ), allocatable :: def_comp_mw (:) !! set of corresponding molecular weights of defined components real ( pr ), allocatable :: scn_mw (:) !! set of corresponding molecular weights of scn cuts real ( pr ) :: plus_mw !!  molecular weight of residual fraction real ( pr ), allocatable :: product_z_mw_i (:) real ( pr ), allocatable , intent ( out ) :: def_comp_w (:) real ( pr ), allocatable , intent ( out ) :: scn_w (:) real ( pr ), intent ( out ) :: plus_w call read_setup ( file , def_comp_nc , scn_nc , scn_nc_ps , numbers_ps ) allocate ( product_z_mw_def_comp ( def_comp_nc )) allocate ( product_z_mw_scn ( scn_nc )) allocate ( def_comp_z ( def_comp_nc )) allocate ( scn_z ( scn_nc )) allocate ( def_comp_mw ( def_comp_nc )) allocate ( scn_mw ( scn_nc )) allocate ( w ( 1 + def_comp_nc + scn_nc )) allocate ( product_z_mw_i ( 1 + def_comp_nc + scn_nc )) allocate ( def_comp_w ( def_comp_nc )) allocate ( scn_w ( scn_nc )) call read_composition ( file , def_comp_z , scn_z , plus_z ) call read_molecular_weight ( file , def_comp_mw , scn_mw , plus_mw ) product_z_mw_def_comp = ( def_comp_z ) * ( def_comp_mw ) product_z_mw_scn = ( scn_z ) * ( scn_mw ) product_z_mw_plus = ( plus_z ) * ( plus_mw ) product_z_mw_i = [ product_z_mw_def_comp , product_z_mw_scn , product_z_mw_plus ] sum_z_mw_i = sum ( product_z_mw_i ) w = ( product_z_mw_i ) / ( sum_z_mw_i ) def_comp_w = w ( 1 : def_comp_nc ) scn_w = w ( def_comp_nc + 1 : def_comp_nc + scn_nc ) plus_w = w ( def_comp_nc + scn_nc + 1 ) end subroutine mass_fractions subroutine read_density ( file , scn_density , plus_density ) !! Reads the density of each component from the input file and calculated molar volume since C6 fraction. character ( len =* ), intent ( in ) :: file !! file name real ( pr ), allocatable , intent ( out ) :: scn_density (:) !! set of corresponding densities of scn cuts real ( pr ), intent ( out ) :: plus_density !! density of residual fraction from input file integer :: def_comp_nc !! number of defined components being considered in the oil integer :: scn_nc !! number of single cuts being considered in the oil integer :: scn_nc_ps !! CN from which all SCN fractions will be lumped into the specified number of pseudos integer :: numbers_ps !! number of pseudos in which the scn fractions grouped integer :: funit namelist / nml_density / scn_density , plus_density call read_setup ( file , def_comp_nc , scn_nc , scn_nc_ps , numbers_ps ) allocate ( scn_density ( scn_nc )) open ( newunit = funit , file = file ) read ( funit , nml = nml_density ) close ( funit ) end subroutine read_density type ( FluidData ) function data_from_file ( file ) result ( data ) !! This funtion allows to obtain experimental data from data imput character ( len =* ), intent ( in ) :: file !! file name data % filename = file call read_setup ( file , data % def_comp_nc , data % scn_nc , data % scn_nc_ps , data % numbers_ps ) call read_components ( file , data % def_components , data % scn , & data % scn_plus ) call read_composition ( file , data % def_comp_z , data % scn_z , data % plus_z ) call read_molecular_weight ( file , data % def_comp_mw , data % scn_mw , & data % plus_mw ) call mass_fractions ( file , data % w , data % product_z_mw_def_comp , & data % product_z_mw_scn , data % sum_z_mw_i , data % product_z_mw_plus , & data % def_comp_w , data % scn_w , data % plus_w ) call read_density ( file , data % scn_density , data % plus_density ) end function data_from_file end module data_from_input","tags":"","loc":"sourcefile/data_input.f90.html"},{"title":"types.f90 – Forcha","text":"This file depends on sourcefile~~types.f90~~EfferentGraph sourcefile~types.f90 types.f90 sourcefile~constans.f90 constans.f90 sourcefile~types.f90->sourcefile~constans.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~types.f90~~AfferentGraph sourcefile~types.f90 types.f90 sourcefile~data_input.f90 data_input.f90 sourcefile~data_input.f90->sourcefile~types.f90 sourcefile~routines.f90 routines.f90 sourcefile~routines.f90->sourcefile~types.f90 sourcefile~routines.f90->sourcefile~data_input.f90 sourcefile~prueba.f90 prueba.f90 sourcefile~prueba.f90->sourcefile~data_input.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module dtypes use constants , only : pr implicit none type :: FluidData integer :: def_comp_nc !! number of defined components being considered in the oil integer :: scn_nc !! number of single cuts being considered in the oil integer :: scn_nc_ps !! CN from which all SCN fractions will be lumped into the specified number of pseudos integer :: numbers_ps !! number of pseudos in which the scn fractions grouped. character ( len = :), allocatable :: filename integer , allocatable :: scn (:) !! set of singles cuts being considered in the oil character ( len = 15 ), allocatable :: def_components (:) !! set of defined components being considered in the oil character ( len = 15 ) :: scn_plus !! name of residual fraction real ( pr ), allocatable :: def_comp_z (:) !! set of corresponding mole fractions of defined components real ( pr ), allocatable :: scn_z (:) !!  set of corresponding mole fractions of scn cuts real ( pr ), allocatable :: def_comp_mw (:) !! set of corresponding molecular weights of defined components real ( pr ), allocatable :: scn_mw (:) !! set of corresponding molecular weights of scn cuts real ( pr ), allocatable :: product_z_mw_def_comp (:) !! product between composition and molecular weight of defind components real ( pr ), allocatable :: product_z_mw_scn (:) !! product between composition and molecular weight of scn fractions real ( pr ) :: sum_z_mw_i !!  sum of the product between composition and molecular weight of the fluid's compounds real ( pr ), allocatable :: w (:) !! mass fractions of the fluid's compounds real ( pr ) :: plus_z !! composition of residual fraction real ( pr ) :: plus_mw !!  molecular weight of residual fraction real ( pr ) :: product_z_mw_plus !! product between composition and molecular weight of residual fraction real ( pr ), allocatable :: def_comp_w (:) !! mass fractions of the defined compounds real ( pr ), allocatable :: scn_w (:) !! !! mass fractions of the scn-s compounds real ( pr ) :: plus_w !! mass fractions of the plus fraction real ( pr ), allocatable :: scn_density (:) !! set of corresponding densities of scn cuts real ( pr ) :: plus_density !! experimental density of the plus fraction end type FluidData type :: FluidDataOut ! incluir aqui las variables que quiero que salgan como salida real ( pr ), allocatable :: scn_z (:) !!  set of corresponding mole fractions of scn cuts calculated real ( pr ), allocatable :: log_scn_z (:) !!  set of corresponding mole fractions of scn cuts calculated real ( pr ) :: plus_mw !!  molecular weight of residual fraction real ( pr ) :: plus_z !! composition of residual fraction real ( pr ) :: C !! C constants which is used in equation M = 84-characterization%C(i-6) real ( pr ), allocatable :: scn_mw (:) !! set of corresponding molecular weights of scn cuts real ( pr ), allocatable :: scn_zm (:) real ( pr ) :: plus_zm real ( pr ) :: a_blr !! A constant for best linear regression line. real ( pr ) :: b_blr !! B constant for best linear regression line. real ( pr ) :: a_60 !! A constant for Cmax60 line. real ( pr ) :: b_60 !! B constant for Cmax60 line. real ( pr ) :: a_lim !! A constant for limit feasible line. real ( pr ) :: b_lim !! B constant for limit feasible line. real ( pr ) :: a !! output real variable. Slope of the best feasible regression line. real ( pr ) :: b !! output real variable. Intercept of the best feasible regression line. real ( pr ) :: r2 !! output real variable. Square correlation coefficient. integer :: n_init ! minimum carbon number obtained from the best linear regression integer :: c_max_blr , c_max_lim , c_max_60 integer :: nc_plus !! number of elements in the distribution of C20+ integer :: c_max !! output CN at which plus_z is reached, as the summation of single z(i) from the best linear distribution (blr) real ( pr ), allocatable :: carbon_number_plus (:) real ( pr ), allocatable :: plus_z_i (:) real ( pr ), allocatable :: product_z_mw_plus_i (:) real ( pr ) :: a_d !! ad constant which is used in equation rho_i = ad*exp(-i/10) +bd for density. real ( pr ) :: b_d !! bd constant which is used in equation rho_i = ad*exp(-i/10) +bd for density. real ( pr ) :: volume_6plus_cal integer :: last_C integer :: i_last real ( pr ), allocatable :: scn_i (:) real ( pr ), allocatable :: plus6_density (:) real ( pr ) :: plus_w end type FluidDataOut end module dtypes","tags":"","loc":"sourcefile/types.f90.html"},{"title":"constans.f90 – Forcha","text":"Files dependent on this one sourcefile~~constans.f90~~AfferentGraph sourcefile~constans.f90 constans.f90 sourcefile~data_input.f90 data_input.f90 sourcefile~data_input.f90->sourcefile~constans.f90 sourcefile~types.f90 types.f90 sourcefile~data_input.f90->sourcefile~types.f90 sourcefile~module.f90 module.f90 sourcefile~module.f90->sourcefile~constans.f90 sourcefile~prueba.f90 prueba.f90 sourcefile~prueba.f90->sourcefile~constans.f90 sourcefile~prueba.f90->sourcefile~data_input.f90 sourcefile~routines.f90 routines.f90 sourcefile~routines.f90->sourcefile~constans.f90 sourcefile~routines.f90->sourcefile~data_input.f90 sourcefile~routines.f90->sourcefile~types.f90 sourcefile~types.f90->sourcefile~constans.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module constants use iso_fortran_env , only : real64 implicit none integer , parameter :: pr = real64 end module constants","tags":"","loc":"sourcefile/constans.f90.html"},{"title":"prueba.f90 – Forcha","text":"This file depends on sourcefile~~prueba.f90~~EfferentGraph sourcefile~prueba.f90 prueba.f90 sourcefile~constans.f90 constans.f90 sourcefile~prueba.f90->sourcefile~constans.f90 sourcefile~data_input.f90 data_input.f90 sourcefile~prueba.f90->sourcefile~data_input.f90 sourcefile~data_input.f90->sourcefile~constans.f90 sourcefile~types.f90 types.f90 sourcefile~data_input.f90->sourcefile~types.f90 sourcefile~types.f90->sourcefile~constans.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module pruebas use constants use data_from_input , only : data_from_file , FluidData contains subroutine Linear_Regression ( x , y , a , b , r2 ) !! This subroutine computes the regression line for a data set of x, y variables. implicit none integer :: i integer :: n !! total number of data set. real ( pr ), intent ( in ) :: x (:) !! x: input array of length n which contains the set of independent variable real ( pr ), intent ( in ) :: y (:) !! y: input array of length n which contains the set of dependent variable real ( pr ) :: t1 , t2 , t3 , t4 , aux1 , aux2 , aux3 , aux4 , aux5 ! internal variables real ( pr ), intent ( out ) :: a !! a: output real variable. Slope of the regression line real ( pr ), intent ( out ) :: b !! b: output real variable. Intercept of the regression line real ( pr ), intent ( out ) :: r2 !! r2: output real variable. Square correlation coefficient n = size ( x ) !Calculation of a y b --> y=a*x+b t1 = 0. ; t2 = 0. ; t3 = 0. ; t4 = 0. ; do i = 1 , n t1 = t1 + x ( i ) * y ( i ) t2 = t2 + x ( i ) t3 = t3 + y ( i ) t4 = t4 + x ( i ) ** 2 end do a = ( n * t1 - t2 * t3 ) / ( n * t4 - t2 ** 2 ) b = ( t3 - a * t2 ) / n !coefficient calculation of correlations r2 aux1 = 0. ; aux2 = 0. ; aux3 = 0. ; aux4 = 0. ; aux5 = 0. ; do i = 1 , n aux1 = aux1 + x ( i ) * y ( i ) aux2 = aux2 + x ( i ) aux3 = aux3 + y ( i ) aux4 = aux4 + x ( i ) ** 2 aux5 = aux5 + y ( i ) ** 2 end do r2 = ( aux1 - aux2 * aux3 / n ) ** 2 / (( aux4 - aux2 ** 2 / n ) * ( aux5 - aux3 ** 2 / n )) end subroutine Linear_Regression subroutine Best_Linear_Regression ( scn_nc , scn , scn_z , plus_z , a , b , r2 , n_init , c_max_blr ) !! This subroutine calculates the best regression line for an oil. implicit none integer , intent ( in ) :: scn_nc !! integer input variable set to the total number of single cuts being considered in the oil integer , allocatable , intent ( in ) :: scn (:) !! set of singles cuts being considered in the oil integer , intent ( out ) :: c_max_blr !! output CN at which plus_z is reached, as the summation of single z(i) from the best linear distribution (blr) real ( pr ), allocatable , intent ( in ) :: scn_z (:) !! set of corresponding mole fractions of scn cuts real ( pr ), intent ( in ) :: plus_z !! composition of residual fraction from input file real ( pr ), intent ( out ) :: a !! output real variable. Slope of the best regression line. real ( pr ), intent ( out ) :: b !! output real variable. Intercept of the best regression line. real ( pr ), intent ( out ) :: r2 !! output real variable. Square correlation coefficient. integer , intent ( out ) :: n_init !! minimum carbon number obtained from the best linear regression integer :: i , j , k , k_old , n_best , x_aux ! internal variables real ( pr ), dimension ( scn_nc ) :: x_blr , y_blr real ( pr ) :: r2_old , r2_best , a_old , b_old , a_best , b_best , z_sum , z_aux k = 5 r2 = 0.0001_pr r2_old = 0.00001_pr r2_best = 0.0001_pr do while ( r2 . gt . r2_old . or . r2_old . lt . 0.9 ) k_old = k r2_old = r2 a_old = a b_old = b if ( r2 . gt . r2_best ) then r2_best = r2 a_best = a b_best = b n_best = scn ( scn_nc - k + 2 ) end if if ( k . gt . scn_nc ) then if ( r2 . gt . r2_best ) then n_init = scn ( scn_nc - k + 2 ) go to 22 else r2 = r2_best a = a_best b = b_best n_init = n_best go to 22 end if end if j = 1 x_blr = 0. y_blr = 0. do i = scn_nc - k + 1 , scn_nc x_blr ( j ) = scn ( i ) y_blr ( j ) = scn_z ( i ) j = j + 1 end do call Linear_Regression ( x_blr (: k ), y_blr (: k ), a , b , r2 ) k = k + 1 end do r2 = r2_old a = a_old b = b_old n_init = scn ( scn_nc - k_old + 2 ) 22 continue z_sum = 0 d0 x_aux = scn ( scn_nc ) do while ( z_sum . lt . plus_z . and . x_aux < 300 ) x_aux = x_aux + 1 z_aux = exp ( a * x_aux + b ) z_sum = z_sum + z_aux end do c_max_blr = x_aux !print*, a, b, c_max_blr, r2, n_init end subroutine Best_Linear_Regression subroutine LimitLine ( scn_nc , scn , plus_z , a_blr , b_blr , a_lim , b_lim , c_max_lim , half ) !! This subroutine obtains the limit line constants for an oil. implicit none integer , intent ( in ) :: scn_nc !! integer input variable set to the total number of single cuts being considered in the oil integer , allocatable , intent ( in ) :: scn (:) !! set of singles cuts being considered in the oil integer , intent ( out ) :: c_max_lim !! output CN at which plus_z is reached, as the summation of single z(i) from the limit distribution (blr) real ( pr ), intent ( in ) :: a_blr !! input constant from the Best linear regression real ( pr ), intent ( in ) :: b_blr !! input constant from the Best linear regression real ( pr ), intent ( in ) :: plus_z !! composition of residual fraction from input file real ( pr ), intent ( out ) :: a_lim !! output real variable. Slope of the limit line real ( pr ), intent ( out ) :: b_lim !! output real variable. Intercept of the limit line. real ( pr ), intent ( out ) :: half real ( pr ) :: z_lim , cross_cn , z_cross , z_aux ! cn: carbon number integer :: x_aux !A and B limit calculation. z_lim = 0.0_pr half = 0.506_pr ! modified by oscar, the variable half was removed fron the argument !print*, scn do while ( z_lim . lt . plus_z ) half = half + 0.002d0 cross_cn = scn ( scn_nc ) + half ! typically 19.508 in first try z_cross = exp (( a_blr * cross_cn ) + b_blr ) a_lim = - ( z_cross ) / plus_z b_lim = log ( z_cross ) - ( a_lim * cross_cn ) x_aux = scn ( scn_nc ) z_lim = 0._pr do while ( z_lim . lt . plus_z . and . x_aux < 300 ) x_aux = x_aux + 1 z_aux = exp ( a_lim * x_aux + b_lim ) z_lim = z_lim + z_aux end do continue end do c_max_lim = x_aux !print*, a_lim,b_lim,c_max_lim end subroutine LimitLine subroutine Line_C60_max ( scn_nc , scn , plus_z , a_blr , b_blr , half , a_60 , b_60 , c_max_60 ) !! This subroutine obtains the Cmax60 line constants for an oil implicit none integer , intent ( in ) :: scn_nc !! integer input variable set to the total number of single cuts being considered in the oil integer , allocatable , intent ( in ) :: scn (:) !! set of singles cuts being considered in the oil integer , intent ( out ) :: c_max_60 !!output CN at which Zp is reached, as the summation of single z(i) from the Cmax60 distribution. real ( pr ), intent ( in ) :: a_blr !! input constant from the Best linear regression real ( pr ), intent ( in ) :: b_blr !! input constant from the Best linear regression real ( pr ), intent ( in ) :: plus_z !! composition of residual fraction from input file real ( pr ), intent ( out ) :: a_60 !! output real variable. Slope of the limit line real ( pr ), intent ( out ) :: b_60 !! output real variable. Intercept of the C60max line. real ( pr ), intent ( in ) :: half integer :: x_aux real ( pr ) :: z_sum , cross_cn , z_cross , z_aux , F_tol , a_tol , var_range real ( pr ) :: a_old , Zp_60 , F , dF_dA cross_cn = scn ( scn_nc ) + half ! typically 19.51 z_cross = exp (( a_blr * cross_cn ) + b_blr ) F_tol = 1_pr a_tol = 1_pr a_60 = a_blr var_range = 6 0.5_pr - cross_cn do while ( a_tol . gt . 1e-6_pr . or . F_tol . gt . 1e-6_pr ) a_old = a_60 Zp_60 = ( exp ( a_60 * var_range + log ( z_cross )) - z_cross ) / a_60 F = plus_z - Zp_60 dF_dA = - ( var_range * ( a_60 * Zp_60 + z_cross ) - Zp_60 ) / a_60 ! modified by oscar, error in the derivative in previous version is corrected a_60 = a_old - ( F / dF_dA ) a_tol = abs ( a_old - a_60 ) F_tol = abs ( F ) end do b_60 = log ( z_cross ) - a_60 * cross_cn z_sum = 0.0_pr x_aux = scn ( scn_nc ) do while ( z_sum . lt . plus_z ) x_aux = x_aux + 1 z_aux = exp ( a_60 * x_aux + b_60 ) z_sum = z_sum + z_aux end do c_max_60 = x_aux !print*, a_60,b_60,c_max_60 end subroutine Line_C60_max subroutine select_method ( oil , mw_source , method , C , log_scn_z , plus_z , plus_mw ) implicit none type ( FluidData ) :: oil !character(len=*), intent(in) :: file !! file name character ( len =* ), intent ( in ), optional :: method character ( len =* ), intent ( in ) :: mw_source real ( pr ), allocatable :: scn_mw (:) !! set to molecular weights calculated by M = 84-C(i-6) real ( pr ) :: C !! C constants which is used in equation M = 84-C(i-6) real ( pr ), allocatable :: scn_z (:) !! set of corresponding calculated mole fractions of scn cuts real ( pr ) :: sum_def_comp_z_plus !! compositions sum from (define component +1) to (plus component) real ( pr ), intent ( out ) :: plus_z !! composition of residual fraction from input file real ( pr ) :: plus_mw !!  calculated molecular weight of  residual fraction real ( pr ), allocatable , intent ( out ) :: log_scn_z (:) !! logarithm of corresponding mole fractions of scn cuts real ( pr ), allocatable :: def_comp_moles (:) real ( pr ), allocatable :: scn_moles (:) real ( pr ) :: plus_moles real ( pr ) :: total_moles !oil = data_from_file(file) allocate ( scn_z ( oil % scn_nc )) allocate ( scn_mw ( oil % scn_nc )) allocate ( log_scn_z ( oil % scn_nc )) allocate ( def_comp_moles ( oil % def_comp_nc )) allocate ( scn_moles ( oil % scn_nc )) def_comp_moles = ( oil % def_comp_w ) / ( oil % def_comp_mw ) select case ( mw_source ) case ( \"experimental\" ) scn_moles = ( oil % scn_w ) / ( oil % scn_mw ) plus_moles = ( oil % plus_w ) / ( plus_mw ) total_moles = sum ( def_comp_moles ) + sum ( scn_moles ) + ( plus_moles ) scn_z = scn_moles / total_moles plus_z = plus_moles / total_moles log_scn_z = log ( scn_z ) case ( \"calculated\" ) if ( method == \"global_mw\" ) then scn_mw = 84 + C * ( oil % scn - 6 ) scn_z = oil % product_z_mw_scn / scn_mw sum_def_comp_z_plus = sum ( oil % scn_z ) + ( oil % plus_z ) plus_z = sum_def_comp_z_plus - sum ( scn_z ) ! new molar fraction for residual cut, based on C plus_mw = oil % product_z_mw_plus / plus_z log_scn_z = log ( scn_z ) end if if ( method == \"plus_mw\" ) then scn_mw = 84 + C * ( oil % scn - 6 ) scn_moles = ( oil % scn_w ) / ( scn_mw ) plus_moles = ( oil % plus_w ) / ( plus_mw ) total_moles = sum ( def_comp_moles ) + sum ( scn_moles ) + ( plus_moles ) scn_z = scn_moles / total_moles plus_z = plus_moles / total_moles log_scn_z = log ( scn_z ) endif end select end subroutine select_method subroutine difference_mw_plus ( oil , mw_source , method , start , C , difference , plus_mw ) !! this subroutine ... implicit none type ( FluidData ) :: oil logical :: start !character(len=*), intent(in) :: file !! file name character ( len =* ), intent ( in ), optional :: method character ( len =* ), intent ( in ) :: mw_source integer :: c_max !! output CN at which plus_z is reached, as the summation of single z(i) from the best linear distribution (blr) real ( pr ), allocatable :: scn_z (:) !! set of corresponding calculated mole fractions of scn cuts integer :: n_init ! minimum carbon number obtained from the best linear regression real ( pr ), allocatable :: log_scn_z (:) !! logarithm of corresponding mole fractions of scn cuts real ( pr ) :: C !! C constants which is used in equation M = 84-C(i-6) real ( pr ) :: plus_z !! composition of residual fraction from input file real ( pr ) :: plus_mw !!  calculated molecular weight of  residual fraction real ( pr ) :: plus_mw_cal !!  calculated molecular weight of  residual fraction real ( pr ), intent ( out ) :: difference !! real ( pr ) :: a !! output real variable. Slope of the best regression line. real ( pr ) :: b !! output real variable. Intercept of the best regression line. real ( pr ) :: r2 !! output real variable. Square correlation coefficient. real ( pr ), allocatable :: x_blr (:), y_blr (:) real ( pr ) :: a_blr , b_blr , a_60 , b_60 , a_lim , b_lim , half real ( pr ) :: r2_old , r2_best , a_old , b_old , a_best , b_best , z_sum , z_aux real ( pr ), dimension ( 300 ) :: plus_z_i real ( pr ), dimension ( 300 ) :: product_z_mw_plus_i !real(pr) ::  plus_mw real ( pr ) :: sum_z integer :: j , k , k_old , n_best , x_aux , i_0 ! internal variables integer :: c_max_blr , c_max_lim , c_max_60 integer :: i real ( pr ), allocatable :: scn_mw (:) !! set to molecular weights calculated by M = 84-C(i-6) real ( pr ) :: sum_def_comp_z_plus !! compositions sum from (define component +1) to (plus component) integer , dimension ( 300 ) :: carbon_number_plus real ( pr ) :: denom !oil = data_from_file(file) allocate ( scn_z ( oil % scn_nc )) allocate ( scn_mw ( oil % scn_nc )) allocate ( log_scn_z ( oil % scn_nc )) allocate ( x_blr ( oil % scn_nc )) allocate ( y_blr ( oil % scn_nc )) 1 i_0 = oil % scn ( oil % scn_nc ) call select_method ( oil , mw_source , method , C , log_scn_z , plus_z , plus_mw ) ! select case call Best_Linear_Regression ( oil % scn_nc , oil % scn , log_scn_z , plus_z , a_blr , b_blr , r2 , & n_init , c_max_blr ) call LimitLine ( oil % scn_nc , oil % scn , plus_z , a_blr , b_blr , a_lim , b_lim , c_max_lim , half ) call Line_C60_max ( oil % scn_nc , oil % scn , plus_z , a_blr , b_blr , half , a_60 , b_60 , c_max_60 ) ! add line by oscar. if ( a_blr < a_lim ) then ! added by oscar 05/12/2023.se elimina por que se agregan las restriccones para C>12 y C<12. a = a_lim b = b_lim else ! this line was removed call Line_C60_max if ( a_blr > a_60 ) then a = a_60 b = b_60 else a = a_blr b = b_blr end if end if sum_z = 0.0_pr i = 0 do while ( sum_z < plus_z . and . i < 300 ) i = i + 1 plus_z_i ( i ) = exp ( a * ( i + i_0 ) + b ) sum_z = sum_z + plus_z_i ( i ) product_z_mw_plus_i ( i ) = plus_z_i ( i ) * ( 84 + C * ( i + i_0 - 6 )) carbon_number_plus ( i ) = i + i_0 end do if ( i == 30 0. and . sum_z < plus_z ) then if ( start ) C = C - 0.07 if (. not . start ) C = C - 0.01 go to 1 end if c_max = i + i_0 plus_z_i ( i ) = plus_z_i ( i ) - ( sum_z - plus_z ) !   Adjustment to Zp (z20+) product_z_mw_plus_i ( i ) = plus_z_i ( i ) * ( 84 + C * ( i + i_0 - 6 )) if ( mw_source == \"experimental\" . and . C > 12 . and . C < 14 ) then !! mayor igual a 12 o menor igual 14. denom = sum (( plus_z_i ( 1 : i )) * (( carbon_number_plus ( 1 : i ) - 6 ))) !! denominator of equation to obtain C value directly C = ( plus_z * ( plus_mw - 84 )) / denom endif plus_mw_cal = sum ( product_z_mw_plus_i ( 1 : i )) / plus_z difference = plus_mw_cal - plus_mw end subroutine difference_mw_plus subroutine get_C_or_m_plus ( oil , mw_source , method , start , C ) !! This subroutine... implicit none type ( FluidData ) :: oil logical :: start !character(len=*), intent(in) :: file !! file name character ( len =* ), intent ( in ), optional :: method character ( len =* ), intent ( in ) :: mw_source integer :: c_max !! output CN at which plus_z is reached, as the summation of single z(i) from the best linear distribution (blr) real ( pr ), allocatable :: log_scn_z (:) !! logarithm of corresponding mole fractions of scn cuts real ( pr ) :: C !! C constants which is used in equation M = 84-C(i-6) real ( pr ) :: plus_z !! composition of residual fraction from input file real ( pr ) :: plus_mw !!  calculated molecular weight of  residual fraction real ( pr ) :: difference !! real ( pr ) :: difference_old , plus_mw_old real ( pr ) :: C_old real ( pr ) :: aux !oil = data_from_file(file) select case ( mw_source ) case ( \"experimental\" ) C = 1 3.5 Start = . true . plus_mw = oil % plus_mw call difference_mw_plus ( oil , mw_source , method , start , C , difference , plus_mw ) print * , C , plus_mw case ( \"calculated\" ) if ( method == 'global_mw' ) C = 13 if ( method == 'plus_mw' ) C = 14 Start = . true . plus_mw = oil % plus_mw call difference_mw_plus ( oil , mw_source , method , start , C , difference_old , plus_mw ) C_old = C if ( method == 'global_mw' ) C = min ( 1 2.8 , C - 0.07 ) if ( method == 'plus_mw' ) C = 1 3.5 Start = . false . call difference_mw_plus ( oil , mw_source , method , start , C , difference , plus_mw ) do while ( abs ( difference ) > 0.1 ) aux = C C = C - difference * ( C - C_old ) / ( difference - difference_old ) C_old = aux difference_old = difference call difference_mw_plus ( oil , mw_source , method , start , C , difference , plus_mw ) end do print * , C , plus_mw end select if ( C > 1 4. or . C < 12 ) then if ( C > 14 ) C = 14 if ( C < 12 ) C = 12 Start = . true . plus_mw = oil % plus_mw call difference_mw_plus ( oil , mw_source , method , start , C , difference_old , plus_mw ) plus_mw_old = plus_mw plus_mw = 0.9 * plus_mw Start = . false . call difference_mw_plus ( oil , mw_source , method , start , C , difference , plus_mw ) do while ( abs ( difference ) > 0.00001 ) aux = plus_mw plus_mw = plus_mw - difference * ( plus_mw - plus_mw_old ) / ( difference - difference_old ) plus_mw_old = aux difference_old = difference call difference_mw_plus ( oil , mw_source , method , start , C , difference , plus_mw ) end do print * , C , plus_mw end if end subroutine get_C_or_m_plus end module pruebas","tags":"","loc":"sourcefile/prueba.f90.html"}]}